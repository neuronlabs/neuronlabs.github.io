{
  "0": {
    "id": "0",
    "title": "Class",
    "content": "Class Due to the requirements of different messages with the same case meaning the rror are distinguished by their classes. The classes are defined in the package github.com/neuronlabs/errors/class. Comparing errors Standard golang errors are mostly comparable using the = sign. Each error returned from the neuron package functions/methods is the *ErrorObject or a slice MultiError, In order to understand their meaning there is a structure called class.Class. Class definition Class is the neuron error classification model. It is a wrapper over uint32 composed of the major, minor and index subclassifications. Each subclassifaction is defined as a different bitwise length number, where the major is composed of 7, minor 10 and index of 15 bits. Example: 44205263 in a binary form is 00000010101000101000010011001111 which decomposes into: 0000001 - major (7 bit) - 1 Class instances class package contains every class instance used by the neuron-core functions and methods. The class might be composed from Major, Minor or Index. Major The Major is uint8 wrapper and is the major error classification. It might be used as a general meaning of the error. Example: &#39;Internal&#39; major specifies all the internal errors Minor The Minor is composed from the Major. It is more specific subclassification of the errors. Example: `InternalQuery` is the minor used to determine internal neuron query errors Class Index The Index is the most specific error subclassification, created from the Minors. Example: &#39;InternalQueryFilter&#39; is the classification composed of the &#39;Filter&#39; index and defines the internal query filter errors. Register Classes In order to expand the possibility of error classification. The class package allows to register Majors, Minors, Indexes and of course the Class structures. The package allows to create new Major by providing RegisterMajor or MustRegisterMajor functions. While having the Major we can create the Minor by using it’s register methods. The Minor might be used as a Class by itself by using NewMinorClass or MustNewMinorClass functions. In order to create the most specific subclassification the Index can be created by using RegisterIndex or MustRegisterIndex methods.",
    "url": "http://localhost:4000/neuron-core/errors/class.html",
    "relUrl": "/neuron-core/errors/class.html"
  },
  "1": {
    "id": "1",
    "title": "Controller",
    "content": "Controller Controller is the structure used by the neuron-core that contains all the application context relation data. The *controller.Controller contains most important variables used by all the packages in neuron-core. It contains mappings - model to structures, model to repository; model definitions, repositories and the configurations. Package Repositories Models Package Package: github.com/neuronlabs/neuron-core/controller is the Golang package that contains Core ORM controller. In order to create and set new controller use the New or MustNew method with the provided config. package main import ( &quot;github.com/neuronlabs/neuron-core/config&quot; &quot;github.com/neuronlabs/neuron-core/controller&quot; ) var cfg *config.Controller func main() { // Read the config // cfg = ReadConfig() c, err := controller.New(cfg) // if the config is not valid the function would return an error. // on the other hand creating the config with MustNew would panic on error. c2 := controller.MustNew(cfg) } Repositories The neuron-core uses the abstraction of the repository.Repository as a data source. Controller registers and stores them, so that the related models might use their data access. Register Repository The repositories might be stored and registered in two ways: With the Controller Config By using RegisterRepository Controller method The repository configurations provided with the Controller Config would be registered while createing the New Controller. The RegisterRepository allows to store manually the *config.Repository for the given ‘name’ within given Controller. Example: cfg := &amp;config.Repository{ Username: testing, Password: testing, DBName: testing1, Port: 5432, Host: localhost, } err = c.RegisterRepository(&quot;my_repository&quot;, cfg) In the example above the following Repository config is stored under the ‘my_repository’ key. All the model’s that are mapped with the ‘my_repository’ Repository, would use the Factory repository credentials shown above. Models Mapping Controller is used to register the models. This creates *mapping.ModelStruct for each model, which have a mapping of the fields Registering Models Model register process should begin only when the related Repositories are already registered. Each model after being mapped, gets their related Repository created by it’s Factory for it’s Model mapping In order to have an model mapping the models needs to be registered within the controller: var c *controller.Controller c := controller.MustGetNew(cfg) err := c.RegisterModels(Model{}, User{}, Dog{}, Cat{}) ...",
    "url": "http://localhost:4000/neuron-core/controller.html",
    "relUrl": "/neuron-core/controller.html"
  },
  "2": {
    "id": "2",
    "title": "Delete",
    "content": "Delete method Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/delete.html",
    "relUrl": "/neuron-core/query/delete.html"
  },
  "3": {
    "id": "3",
    "title": "Error Struct",
    "content": "Error Struct Every package in the neuron-core returns errors defined in the github.com/neuronlabs/errors. The structure *ErrorObject is created using the New and Newf methods. Each requires error specific class.Class and the message. The second function Newf allows the message to be formatted with the provided arguments. The *ErrorObject is composed of ID (UUID), class.Class, message, detail and an operation at which it occurred. ID is unique for that specific occurrence UUID identification number Class defines the error classification Message is the string returned by the Error method, and is a main error message. Detail is the human readable, optional detail for the given error occurrence. Operation is the optional information about given operation In case if more errors are returned at once, there is a wrapper over the slice of *ErrorObject - MultiError. By itself it implements the error interface, and combines the error message of multiple errors.",
    "url": "http://localhost:4000/neuron-core/errors/error_struct.html",
    "relUrl": "/neuron-core/errors/error_struct.html"
  },
  "4": {
    "id": "4",
    "title": "Fieldset",
    "content": "Fieldset Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/fieldset.html",
    "relUrl": "/neuron-core/query/fieldset.html"
  },
  "5": {
    "id": "5",
    "title": "Filters",
    "content": "Filters Neuron’s query results might get narrowed by the filters. The github.com/neuronlabs/neuron/query/filters package contains all the necessary structures and methods that allows to specify what results we would like to obtain from the query. The filtering system used by Neuron is based on the model’s collection, field (optionally subfield), operator and the values. String Query Filter Filter Fields Operators String Query Filters The filter seperates the logic with the [, ] brackets. It consists of the collection, field, (optionally subfield), the operator and the values. The form of the string filter: filter[collection][field][$operator]=values filter[collection][relationship-field][field][$operator]=values filter[collection][relationship-field][related-field][field][$operator]=values ... The filter for the cars collection on field id with the value that is equal to 42 would look as follows: filter[cars][id][$eq]=42 In order to filter the field over it’s relationship values the relationship field must have it’s subfield defined within the filter i.e. in order to filter the cars collection over it’s relationship field driver - where the driver name is equal to Mark the following filter have to be applied: filter[cars][driver][name][$eq]=Mark In order to add the filter to the given scope use the AddStringFilter method to the query.Scope: if err = s.AddStringFilter(&quot;filter[cars][driver][name][$eq]&quot;, &quot;Mark&quot;); err != nil { // error occurs if the field doesn&#39;t exists panic(err) } If the query filter is on the different collection use the filters.NewStringFilter() method FilterField The second way to create a filter is to create the *filters.FilterField using the ModelStruct, it’s StructField, the *filters.Operator and the specific values. The package github.com/neuronlabs/neuron/query/filters contains the NewFilter function that is used to create the FilterField I.e. we want to create the filter to the cars collection query scope, that will filter the doors where it’s numbers is greater than or equal to 4 Then we should create it in a following way: Create the scope for the Cars field var c *Controller // Get the controller // we assume it is already created with the `Car` model var cars []*Car s, err := query.NewC(c, &amp;cars) if err != nil { panic(err) } Get the scope’s ModelStruct and the StructField we want in the filter. doorField, ok := s.Struct().Attr(&quot;doors&quot;) if !ok { panic(&quot;No doors field found&quot;) } Create and add new filter field // import &quot;github.com/neuronlabs/neuron/query/filters&quot; err = s.AddFilter(filters.NewFilter(doorField, filters.OpGreaterEqual, 4)) if err != nil { // the error might occur if the field is not found within the model&#39;s // struct field panic(err) } Operators Neuron implements the following basic filter operators: ID Name Query String Value Variable Name Description 1 Equal $eq *filters.OpEqual Matches values that are equal to the specified value 2 In $in *filters.OpIn Matches any values that are in the specified range of values` 3 Not Equal $ne *filters.OpNotEqual Matches values that are not euqal to the specified value 4 Not In $nin *filters.OpNotIn Matches any values that are not in the specified range of values 5 Greater Than $gt *filters.OpGreaterThan Matches any value that is greater than the specified value 6 Greater Than Equal $ge *filters.OpGreaterEqual Matches any value that is greater than or equal to the specified value 7 Less Than $lt *filters.OpLessThan Matches any value that is smaller than the specified value 8 Less Than Equal $le *filters.OpLessEqual Matches any value that is smaller than or equal to the specified value 9 Contains $contains *filters.Contains The operator used for the string variables, matches any values that contains the specified string value 10 Starts With $startswith *filters.StartsWith Used for the string variables, matches any values that starts with the specified string value 11 Ends With $endsswith *filters.EndsWith Used for the string variables, matches any values that ends with the specified string value 12 Is Null $isnull *filters.IsNull Matches all objects for which given field value is null 13 Not Null $notnull *filters.NotNull Matches all objects for which given field value is not null It is also allowed to have the custom operator, which might be used within the hooks and changed into the basic filters, or used in pair with the required handler for the specific repository. Custom Operators Neuron allows to use the custom operators. In order to use it The operator should be registered in the github.com/neuronlabs/neuron/query/filters package as well as in the repository on which it would be used. The custom operator should be created in the following way: Create new *filters.Operator object: myOperator := &amp;filters.Operator{Name: &quot;MyOperator&quot;, Raw:&quot;$my&quot;} The operator should have unique Name nad Raw fields. The Raw field should start with the ‘$’ dollar sign. Then the operator should be registered in the query filters: if err = filters.RegisterOperator(myOperator); err != nil { panic(err) } If we want to use this operator in the specified repostiory we should register it there as well (if the implementation allows it) - probably with the handler Otherwise the operator might be used within hooks and then replaced into the basic operators",
    "url": "http://localhost:4000/neuron-core/query/filters.html",
    "relUrl": "/neuron-core/query/filters.html"
  },
  "6": {
    "id": "6",
    "title": "Get",
    "content": "Getting Single Data Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/get.html",
    "relUrl": "/neuron-core/query/get.html"
  },
  "7": {
    "id": "7",
    "title": "Mongo Repository",
    "content": "Mongo Repository",
    "url": "http://localhost:4000/neuron-mongo/",
    "relUrl": "/neuron-mongo/"
  },
  "8": {
    "id": "8",
    "title": "Query",
    "content": "Query Structure Neuron-core’s architecture allows to query models with their relations located on separate databases, stores or services. This forces the query to be very precise in it’s structure. Each query is stored as the query.Scope which consists of the following components: ID - unique query id number (UUID) Value - query specific value/values Filters - query filters divided by the field types Primary Key filters Foreign Keys filters Attribute filters Relationship filters Filter Keys filters Fieldset - set of fields that must be returned with their values from the repository Selected Fields - set of fields selected to create/change any repository model Sorting Order - sorting order of the query Pagination - query paginations ID Each query scope contains uniquely set ID stored as UUID. Value Query’s value defines the values to be returned (GET and LIST), created (CREATE), changed (PATCH) or deleted (DELETE).",
    "url": "http://localhost:4000/neuron-core/query/",
    "relUrl": "/neuron-core/query/"
  },
  "9": {
    "id": "9",
    "title": "Errors",
    "content": "Errors The need to recognize the error types on the run, that might have different messages but the same meaning, was the cause to implement it’s own error classification system. Neuron provides it’s own error system, focused on the error meaning recognition.",
    "url": "http://localhost:4000/neuron-core/errors/",
    "relUrl": "/neuron-core/errors/"
  },
  "10": {
    "id": "10",
    "title": "Core ORM",
    "content": "Core ORM Neuron-core is the golang cloud-native, distributed ORM implementation. What is Neuron Core? Install Quickstart Design Packages What is Neuron Core? Neuron-core is a cloud-ready Golang ORM. It’s design allows to query multiple related models located on different datastores/repositories. Install go get -u github.com/neuronlabs/neuron-core Quick Start Define the models package models // User is the model that is stored on the &#39;main&#39; repository. // It is related to multiple &#39;Pet&#39; models. type User struct { ID int Name string Surname string Pets []*Pet `neuron:&quot;type=relation;foreign=OwnerID&quot;` } // Pet is the model related with the User. // It is stored in the &#39;secondary&#39; repository. type Pet struct { ID int Name string OwnerID int `neuron:&quot;type=foreign&quot;` } // RepositoryName implements RepositoryNamer interface. func (p *Pet) RepositoryName() string { return &quot;secondary&quot; } Import repositories and Create, Read or get Default *config.Controller package main import( // blank imported repository registers it&#39;s factory // and the driver. _ &quot;github.com/neuronlabs/neuron-pq&quot; ) import ( &quot;github.com/neuronlabs/neuron-core/config&quot; &quot;github.com/neuronlabs/neuron-core&quot; ) func main() { cfg := config.ReadDefaultConfig() // By setting the LogLevel the default logger would be used. cfg.LogLevel = &quot;debug&quot; ... Create the *controller.Controller and register repositories. // Provided create config &#39;cfg&#39; to the Controller method. c := ncore.Controller(cfg) // As the &#39;neuron-core&#39; allows to use multiple repository for the models // we can declare the DefaultRepository within the config. The first // registered repository would be set as the default as well. mainDB := &amp;config.Repository{ // Currently registered repository &#39;neuron-pq&#39; has it&#39;s driver name: &#39;pq&#39;. DriverName: &quot;pq&quot;, Host: &quot;localhost&quot;, Port: &quot;5432&quot;, Username: &quot;main_db_user&quot;, Password: &quot;main_db_password&quot;, DBName: &quot;main&quot;, } if err := c.RegisterRepository(&quot;main&quot;, mainDB); err != nil { panic(err) } // We can register and use different repository for other models. secondaryDB := &amp;config.Repository{ DriverName: &quot;pq&quot;, Host: &quot;172.16.1.10&quot;, Port: &quot;5432&quot;, Username: &quot;secondary_user&quot;, Password: &quot;secondary_password&quot;, DBName: &quot;secondary&quot;, } // Register secondary repository. if err := c.RegisterRepository(&quot;secondary&quot;, secondaryDB); err != nil { panic(err) } Register models if err := c.RegisterModels(models.User{}, models.Pet{}); err != nil { panic(err) } Query registered models users := []*User{} s := ncore.MustQueryC(c, &amp;users) // the query scope may be filtered s.AddStringFilter(&quot;filter[users][name][$in]&quot;,&quot;John&quot;, &quot;Sam&quot;) // it might also be sorted s.SortBy(&quot;-id&quot;) // list all the users with the name &#39;John&#39; or &#39;Sam&#39; with &#39;id&#39; ordered // descending. if err = s.List(); err != nil { panic(err) } Packages The neuron-core is composed of the following packages: query - used to query the model’s repositories. controller - is the neuron’s core, that registers and stores the models and contains configurations required by other packages. mapping - contains the information about the mapped models their fields and settings config - contains the configurations structures. encoding/jsonapi - allows to marshal and unmarshal the model’s, and queries by the https://jsonapi.org/ specification errors - used as a default error package for the neuron packages. errors/class - contains errors classification system for the neuron packages repository - is a package used to store, get and register the repositories nad their factories. log - is the logging interface for the neuron based applications. i18n - is the neuron based application supported internationalization common - common neuron variables, functions and definitions.",
    "url": "http://localhost:4000/neuron-core",
    "relUrl": "/neuron-core"
  },
  "11": {
    "id": "11",
    "title": "Gateway",
    "content": "Gateway",
    "url": "http://localhost:4000/neuron-gateway/",
    "relUrl": "/neuron-gateway/"
  },
  "12": {
    "id": "12",
    "title": "Postgres Repository",
    "content": "Postgres Repository Neuron PQ is the Neuron-Core Postgres repository driver. It contains",
    "url": "http://localhost:4000/neuron-pq/",
    "relUrl": "/neuron-pq/"
  },
  "13": {
    "id": "13",
    "title": "Neuron",
    "content": "Neuronlabs The Neuron is the Golang based project with a scope to deliver top quality, cloud-native, microservice ready framework for building and creating services. Table of Contents Core Core Query Repositories",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "14": {
    "id": "14",
    "title": "Insert",
    "content": "Insert data In order to insert the data create a new query with the provided value: user := &amp;User{Name: &quot;Jack&quot;} s, err := query.New(user) if err != nil { return err } Any create query may have specified it’s Selected Fields. The selected fields are the field’s which values would be inserted into repository. By default the query processor scans provided scope.Value for non-zero field values and uses them as the selected fields. By specifing selected fields the query might insert zero-valued fields. err = s.SelectFields(&quot;Name&quot;, &quot;Age&quot;) if err != nil { return err } When the create query preparation is finished then the Create method should be used on the query.Scope. err = s.Create() OR with respect to the provided context.Context: ctx, cancel := context.WithTimeout(context.Background, time.Second * 5) defer cancel() err = s.CreateContext(ctx) If the query.Scope doesn’t have primary field selected then the repository should create new model instance and set it’s ID value into model’s primary field value. id := user.ID // newly created model&#39;s ID Relations While inserting the model, neuron allows to set the relations for given model within a single query. If the relationship field primary field(s) is non-zero then after having the root model value created, the following relationship field would have it’s relationship model’s patched with the selected foreign keys. user := &amp;User{Name: &quot;Thomas&quot;, Pets: []*Pet{ID: 5}} s, err = query.New(user) if err != nil { return err } // the Create query would create new user with name Thomas // and patch pets model&#39;s with id: &#39;5&#39; so that it&#39;s foreign key is set // to newly created user&#39;s id. err = s.Create() if err != nil { return err } Errors While patching the related values an error might occur. If the query was within a single transaction, then // possible strategies: transaction: rollback all changes of the query non transactions: return error - this should be done within a transaction - any change might provide continue WithTimeout error",
    "url": "http://localhost:4000/neuron-core/query/insert.html",
    "relUrl": "/neuron-core/query/insert.html"
  },
  "15": {
    "id": "15",
    "title": "List",
    "content": "List method Listing the data is one of the most important ORM functions. Neuron allows to query along multiple repositories joining all the relations for each single data instance. Code Creating a List Query requires to provide an address of slice of models, to the query.New, query.NewC, query.MustNew, query.MustNewC functions: users := []*User{} s, err := query.New(&amp;users) Having prepared the query scope, we can specify what data we would like to obtain. // add the field filter if err = s.AddStringFilter(&quot;filter[users][id][$ne]=51&quot;); err != nil { return err } limit := 5 offset := 12 // limit the values number at specific offset if err = s.Limit(limit, offset); err != nil { return err } // Set the return field set if err = s.SetFieldset(&quot;name&quot;, &quot;pets&quot;); err != nil { return err } // sort by the primary field in a decreasing order if err = s.SortBy(&quot;-id&quot;); err != nil { return err } Such prepared query Scope is ready for basic query preparation. The List or ListContext methods would do the list process. // if we have a context we need to include into consider use ListContext method // otherwise choose List. if err = s.List(); err != nil { return err } // now the scope value - variable &#39;users&#39; should contain // the required values.",
    "url": "http://localhost:4000/neuron-core/query/list.html",
    "relUrl": "/neuron-core/query/list.html"
  },
  "16": {
    "id": "16",
    "title": "Models",
    "content": "Models Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Model Definitions Config Repository Model Structure Field Types Field Structure Field Tags Model Definitions Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Config Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Repository Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Model Structure Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Field Types Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Field Structure Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Field Tags Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/models.html",
    "relUrl": "/neuron-core/models.html"
  },
  "17": {
    "id": "17",
    "title": "Pagination",
    "content": "Pagination Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/pagination.html",
    "relUrl": "/neuron-core/query/pagination.html"
  },
  "18": {
    "id": "18",
    "title": "Patch",
    "content": "Patch method Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/patch.html",
    "relUrl": "/neuron-core/query/patch.html"
  },
  "19": {
    "id": "19",
    "title": "Processor",
    "content": "Query Processor",
    "url": "http://localhost:4000/neuron-core/processor.html",
    "relUrl": "/neuron-core/processor.html"
  },
  "20": {
    "id": "20",
    "title": "Repositories",
    "content": "Repositories Neuron-core use the repositories as the database/data store/service access. The main abstractions of the repositories are repository.Factory and a repository.Repository. Factory The Factory is the abstraction used to create new repository instances. It is also responsible for keeping the instances and closing them. Each factory have a unique driver name, which is used by the repositories configurations (*config.Repository) and by the *controller.Controller which is responsible to get the appropiate factory and create new repository instances for the models. The Factory should be registered within the neuron-core on package initialization. Custom factory skeleton may look like in the following example: package myfactory import ( &quot;context&quot; &quot;github.com/neuronlabs/neuron-core/mapping&quot; &quot;github.com/neuronlabs/neuron-core/repository&quot; ) // this factory should be registered on the blank import. func init(){ // this factory would be registered with the driver name // defined as in the factory &#39;DriverName&#39; method. if err := repository.RegisterFactory(&amp;Factory{}); err != nil { panic(err) } } // the Factory must implement repository.Factory interface. var _ repository.Factory = &amp;Factory{} // Factory is the neuron repository.Factory implementation // of the custom repository factory. // Implements repository.Factory. type Factory { instances []*Repository ... } // DriverName implements repository.Factory interface. func (f *Factory) DriverName() string { return &quot;myfactory&quot; } // New implements repository.Factory interface. func (f *Factory) New(c repository.Controller, model *mapping.ModelStruct) (repository.Repository, error) { // Do the logic and create (or use existing) repository instance. } // Close implements repository.Factory interface. func (f *Factory) Close(ctx context.Context, done chan&lt;-interface{}) { for _, instance := range f.instances { if err := instance.Close(ctx); err != nil { // handle the error } } // send the information that it finished the closing methods. done &lt;- struct{} } The repository.Factory is an interface used to create new instances of the repository.Repository. This interface requires to implement three methods: DriverName() - which gets the unique driver name for the given factory. New(c Controller,model *mapping.ModelStruct) (repository.Repository, error)- create new instance of the repository for given ‘model’. The Controller argument is an interface for the controllers that is used to get model structures. If the Repositories share similar connection configuration it may use the existing instance instead of creating new. The model specific repository configuration are obtainable by using model.Config().Repository Close(context.Context, done chan&lt;-interface{}) closes all the instances of the factory related repositories. Repository The Repository is the abstraction used to get the access to the data/service. It may be a used as the ORM access to the database, http.Client to some external service or just a custom accessability by using provided interfaces. The repository.Repository is the basic and required interface for the all the repository implementaions. The Repository instances should be created by it’s specific Factory. While registering the models, the controller stores the mapping between repositories and related models. All the Repository methods should not be used by the user directly. In order to access the data or service the Repository may implement specific interfaces defined in the query package like: Creator - creates and stores new instances of the model. Getter - gets a single instance of the specific model. Lister - lists multiple instances of the given model. Patcher - patches only selected model’s value. Deleter - deletes the model instances. Transactioner - allows to use the transactions. Creator func (r *Repository) (ctx context.Context, scope *query.Scope) error { // Do the create logic here return nil } The Create method of the Creator interface requires the Repository to create a specific model instance. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. Provided ‘scope’ structure contains multiple important information about given query like: scope.Value - scope.Value contains the model instance in a pointer to struct type. SelectedFields() - fields used in the current query.Scope. Only these fields should be stored by this query. It might be useful if a user would like to select and store the zero value fields. If the primary field is not selected, then the Repository should generate new primary field value and set it to the model’s scope.Value instance. Struct() - gets *mapping.ModelStruct for the specific query. The model structure has information about all it’s fields. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). Getter and Lister Getter func (r *Repository) Get(ctx context.Context, scope *query.Scope) error { // Do the get logic here return nil } Lister func (r *Repository) List(ctx context.Context, scope *query.Scope) error { // Do the logic here return nil } Both Get method from the Getter and List from the Lister interface should get a specific model instances for provided query ‘scope’. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. The get method must not return more than one value instance - (scope.Value is a pointer to the model struct). In order to narrow the scope of the query the *query.Scope contains multiple important information like: PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. Fieldset() - fieldset is a set of fields returned for each model for given query. Pagination() - a pagination paramters for given query. Get method must always return a single value, even if the pagination is limited to more than one result. scope.Value - the value where the results should be stored. It’s instance is already initialized and must not be overwritten. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If there no resultant value was found in related datastore/database then the repository should return an error with no result error classification. Patcher func (r *Repository) Patch(ctx context.Context, scope *query.Scope) error { // Do the patch logic here return nil } The Patch method from the Patcher interface should patch models with the values provided by the ‘scope’. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. Provided scope contains a single value instance with specific field values, with related filters used to narrow the query. The patch should update only the fields defined in the scope’s selected fields. Useful parameters stored in the scope: scope.Value - the value where the field’s values are stored. It’s instance is already initialized and must not replaced with new model’s instance. PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. SelectedFields() - fields used in the current query.Scope. Only these fields should be used by this query. It might be useful if a user would like to select and store the zero value fields. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If there no resultant value was found in related datastore/database then the repository should return an error with no result error classification. Deleter func (r *Repository) Delete(ctx context.Context, scope *query.Scope) error { // Do the delete logic. return nil } The Delete method from the Deleter interface should delete all the matching model instances defined by the given query scope. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. The scope should contain all the required filters: PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If no values were affected with given query then the repository should return an error with no result error classification. Transactioner The Transactioner interface requires the Repository to implement transactions for the specific queries. The transaction’s should be isolated for the specific Repository (the single repository might be used for multiple models with the same database). The scope has a Tx() method which returns the scope’s transaction structure. This structure contains the Transaction type and it’s unique ID - this value should be used to map the transaction instances. Begin func (r *Repository) Begin(ctx context.Context, scope *query.Scope) error { // Begin the transaction return nil } The Begin method should begin the repository specific transaction. In order to follow up the transactions the Repository on Begin should store related transactions ‘id’ with it’s specific structures - i.e. sql.Tx as well as Begin a transaction on it’s store/database. The transaction should be created with the specific ‘ctx’ context. Commit func (r *Repository) Commit(ctx context.Context, scope *query.Scope) error { // Commit the transaction changes return nil } If the query resulted with no error then the transaction should be commited. The Commit method allows to apply the transaction changes and remove the mapping transaction mapping. Rollback func (r *Repository) Rollback(ctx context.Context, scope *query.Scope) error { // Rollback any changes made by the transation. return nil } If the transaction were rolled back then the Rollback should undo the changes made within given transaction, and remove the transaction mapping. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`).",
    "url": "http://localhost:4000/neuron-core/repositories.html",
    "relUrl": "/neuron-core/repositories.html"
  },
  "21": {
    "id": "21",
    "title": "Selected Fields",
    "content": "Selected Fields Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/selected_fields.html",
    "relUrl": "/neuron-core/query/selected_fields.html"
  },
  "22": {
    "id": "22",
    "title": "Sorts",
    "content": "Sorts Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/query/sorts.html",
    "relUrl": "/neuron-core/query/sorts.html"
  },
  "23": {
    "id": "23",
    "title": "Transactions",
    "content": "Transactions Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Begin Commit Rollback Begin Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Commit Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Rollback Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/transactions.html",
    "relUrl": "/neuron-core/transactions.html"
  }
  
}
