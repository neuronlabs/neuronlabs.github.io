{
  "0": {
    "id": "0",
    "title": "Class",
    "content": "Class Due to the requirements of different messages with the same case meaning the rror are distinguished by their classes. The classes are defined in the package github.com/neuronlabs/errors/class. Comparing errors Standard golang errors are mostly comparable using the = sign. Each error returned from the neuron package functions/methods is the *ErrorObject or a slice MultiError, In order to understand their meaning there is a structure called class.Class. Class definition Class is the neuron error classification model. It is a wrapper over uint32 composed of the major, minor and index subclassifications. Each subclassifaction is defined as a different bitwise length number, where the major is composed of 7, minor 10 and index of 15 bits. Example: 44205263 in a binary form is 00000010101000101000010011001111 which decomposes into: 0000001 - major (7 bit) - 1 0101000101 - minor (10 bit) - 325 000010011001111 - index (15 bit) - 1231 Class instances class package contains every class instance used by the neuron-core functions and methods. The class might be composed from Major, Minor or Index. Major The Major is uint8 wrapper and is the major error classification. It might be used as a general meaning of the error. Example: &#39;Internal&#39; major specifies all the internal errors Minor The Minor is composed from the Major. It is more specific subclassification of the errors. Example: `InternalQuery` is the minor used to determine internal neuron query errors Class Index The Index is the most specific error subclassification, created from the Minors. Example: &#39;InternalQueryFilter&#39; is the classification composed of the &#39;Filter&#39; index and defines the internal query filter errors. Register Classes In order to expand the possibility of error classification. The class package allows to register Majors, Minors, Indexes and of course the Class structures. The package allows to create new Major by providing RegisterMajor or MustRegisterMajor functions. While having the Major we can create the Minor by using it’s register methods. The Minor might be used as a Class by itself by using NewMinorClass or MustNewMinorClass functions. In order to create the most specific subclassification the Index can be created by using RegisterIndex or MustRegisterIndex methods.",
    "url": "http://localhost:4000/neuron-core/errors/class.html",
    "relUrl": "/neuron-core/errors/class.html"
  },
  "1": {
    "id": "1",
    "title": "Config",
    "content": "Config While registering the models, each ModelConfig defined under model’s collection in the Controller&#39;s ` Config would be set in the ModelStruct` definition. It’s RepositoryName value defines to which repository should the model be connected. The Store field is being copied to the model’s store values. This allows to specify repository related variables. The AutoMigrate flag is the information to the repository if the model should be migrated within the repository (database tables etc).",
    "url": "http://localhost:4000/neuron-core/models/config.html",
    "relUrl": "/neuron-core/models/config.html"
  },
  "2": {
    "id": "2",
    "title": "Controller",
    "content": "Controller Package: github.com/neuronlabs/neuron-core/controller Controller is the structure used by the neuron-core that contains all the application context relation data. The *controller.Controller contains most important variables used by all the packages in neuron-core. It contains mappings - model to structures, model to repository; model definitions, repositories and the configurations. Package Repositories Models Create Controller In order to create and set new controller use the New or MustNew method with the provided config. package main import ( &quot;github.com/neuronlabs/neuron-core/config&quot; &quot;github.com/neuronlabs/neuron-core/controller&quot; ) var cfg *config.Controller func main() { // Read the config // cfg = ReadConfig() c, err := controller.New(cfg) // if the config is not valid the function would return an error. // on the other hand creating the config with MustNew would panic on error. c2 := controller.MustNew(cfg) } Repositories The neuron-core uses the abstraction of the repository.Repository as a data source. Controller registers and stores them, so that the related models might use their data access. Register Repository The repositories might be stored and registered in two ways: With the Controller Config By using RegisterRepository Controller method The repository configurations provided with the Controller Config would be registered while createing the New Controller. The RegisterRepository allows to store manually the *config.Repository for the given ‘name’ within given Controller. Example: cfg := &amp;config.Repository{ Username: testing, Password: testing, DBName: testing1, Port: 5432, Host: localhost, } err = c.RegisterRepository(&quot;my_repository&quot;, cfg) In the example above the following Repository config is stored under the ‘my_repository’ key. All the model’s that are mapped with the ‘my_repository’ Repository, would use the Factory repository credentials shown above. Models Mapping Controller is used to register the models. This creates *mapping.ModelStruct for each model, which have a mapping of the fields Registering Models Model register process should begin only when the related Repositories are already registered. Each model after being mapped, gets their related Repository created by it’s Factory for it’s Model mapping In order to have an model mapping the models needs to be registered within the controller: var c *controller.Controller c := controller.MustGetNew(cfg) err := c.RegisterModels(Model{}, User{}, Dog{}, Cat{}) ...",
    "url": "http://localhost:4000/neuron-core/controller.html",
    "relUrl": "/neuron-core/controller.html"
  },
  "3": {
    "id": "3",
    "title": "Delete",
    "content": "Deleting data Deleting the data instances is based on the query scope filters. Create new query scope for the model that would be deleted: // we want to delete the users collection&#39;s instance with id: &#39;4&#39; u := User{ID: 4} // prepare the query scope s := norm.MustNew(&amp;u) Filters In order to delete the data model’s instance we need to provide query scope filters. If the model provided in the query creation method contains non-zero primary field value, the neuron processor sets it’s value to scope’s primary filter. Deleting Methods When the query scope is ready for deleting, use the query Scope’s methods: Delete or DeleteContext if the query should be based on the ‘context.Context’. err = s.Delete() if err != nil // a different logic may be provided for specified error. // If no values were deleted the processor returns errors with class // QueryValueNoResult. if !errors.IsNoResult(err) { return err } } Relations While deleting current data instance the processor clears also related relationship foreign keys. In future versions of the Core ORM each relationship would have it&#39;s change strategy. The strategy would differ the processes on data deletion, depending on the user&#39;s choice. BelongsTo In BelongsTo relationship the root model contains a foreign key which would be deleted with the model indstance. HasOne The models with HasOne relationships would have related model’s foreign keys deleted. HasMany The models with HasMany relationships would have related model’s foreign keys deleted. ManyToMany The models with Many2Many relationships would have related model’s foreign keys deleted from the join model.",
    "url": "http://localhost:4000/neuron-core/query/delete.html",
    "relUrl": "/neuron-core/query/delete.html"
  },
  "4": {
    "id": "4",
    "title": "Error Struct",
    "content": "Error Struct Every package in the neuron-core returns errors defined in the github.com/neuronlabs/errors. The structure *ErrorObject is created using the New and Newf methods. Each requires error specific class.Class and the message. The second function Newf allows the message to be formatted with the provided arguments. The *ErrorObject is composed of ID (UUID), class.Class, message, detail and an operation at which it occurred. ID is unique for that specific occurrence UUID identification number Class defines the error classification Message is the string returned by the Error method, and is a main error message. Detail is the human readable, optional detail for the given error occurrence. Operation is the optional information about given operation In case if more errors are returned at once, there is a wrapper over the slice of *ErrorObject - MultiError. By itself it implements the error interface, and combines the error message of multiple errors.",
    "url": "http://localhost:4000/neuron-core/errors/error_struct.html",
    "relUrl": "/neuron-core/errors/error_struct.html"
  },
  "5": {
    "id": "5",
    "title": "Fields",
    "content": "StructField A *mapping.StructField is the mapped model’s field. It contains neuron information about given field, such as: ModelStruct - the model where the field is defined Neuron Name - is the field’s name converted using controller’s defined NamerFunc. Name - the structField’s Name. FieldKind - is the neuron kind of the field: Primary Key Foreign Key Attribute RelationshipSingle RelationshipMultiple Filter Key Nested - for the nested attributes Nested - nested structure for the nested field types. Relationship - relationship contains information about the field’s relation to another model. ReflectField - is the reflect.StructField reflection Store - is the key:value storage for given field. Field Tags In order to specify field’s specifictaion each field may be tagged with some specific tag. The basic struct tag is named: neuron. Under this tag there might be multiple tags seperated with ; sign. Each tag may take additional key=value seperated with ,. Fields tagged with - would not be mapped into neuron structures. Example: type TestingModel struct { ID string `neuron:&quot;type=primary&quot;` Name string `neuron:&quot;type=attr;flags=omitempty,nosort&quot;` NonNeuronField int `neuron:&quot;-&quot;` } // ID field has a neuron tags: `type` with value `primary` // Name field has tags: // - &#39;type&#39; with value &#39;attr&#39; - Attribute field // - &#39;flags&#39; with values seperated by &#39;,&#39; - &#39;omitempty&#39; and &#39;nosort&#39;. // NonNeuronField has tag: &#39;-&#39; which defines that // this is not a neuron field, omit and don&#39;t map it. Tags: Tag Description Requirements name Define the name of the field   type Define the field type   foreign Define the name(‘s) for the foreign key(‘s) for given relationship Relationship many2many Defined given field as Many2Many relationship. If the values are provided, the first would be a foreign key and the second - related model’s foreign key. ToMany Relationship flags Struct field tag that allows to store the field’s flags - - Omits given field in mapping process   Flags Field’s flags changes the field’s definitions. They’re defined in the struct field’s tag under neuron-&gt;flags tag. It is also allowed to specify flags within the Field’s Config store. Flag Description Requirements client-id Defines if the provided field allows to create new model instances with user defined ID values Primary Key Field nofilter Disallow to filter the model by given field   nosort Disallow to sort the model by given field   omitempty encoding/jsonapi would omit this field if it’s value is empty   hidden encoding/jsonapi would not marshal this field   lang given field is a language type field Attribute, Singleton in given Model iso8601 Is the marshaling and unmarshaling information about the format of given time field Time field Field Types Tags Allowed field type tags: Tag Description primary, primary_key, primarykey, id, pk primary key field definitions attr, attribute Attribute fields type relation, relationship Relationship field types foreign, foreign_key, foreignkey, fk Foreign key type definiton filterkey Filter Key type definition",
    "url": "http://localhost:4000/neuron-core/models/field.html",
    "relUrl": "/neuron-core/models/field.html"
  },
  "6": {
    "id": "6",
    "title": "Fieldset",
    "content": "Fieldset Query fieldset defines the fields that would be returned with the query resutls. It is used on results of Get and List methods. If no fields in fieldset were specified for the query, the processor would add all the possible model’s fields. While listing multiple values or querying over the relationships it might significantly increase the query speed. JSONAPI The package encoding/jsonapi uses fieldset in MarshalScope functions. It defines which attributes and relationships should be marshaled into output data. Fieldset Methods The *query.Scope provide following methods for the access to the fieldset: AddToFieldset Adds ‘fields’ to the fieldset of the scope. Each field might be a string struct field Name, Neuron Name or a *mapping.StructField. Returns error if the field is not found within the query scope root model. err := scope.AddToSelectedFields(&quot;Name&quot;, &quot;custom_neuron_name&quot;) List Fieldset Fieldset method returns all the fields in the scope’s Fieldset. The returned fields are: []*mapping.StructField. var fieldset []*mapping.StructField fieldset = scope.Fieldset() In Fieldset The InFieldset method checks if provided field is in the scope’s Fieldset. The ‘field’ might be a StructField Name or a Neuron Name. isInFieldset, err := scope.InFieldset(&quot;Name&quot;)",
    "url": "http://localhost:4000/neuron-core/query/fieldset.html",
    "relUrl": "/neuron-core/query/fieldset.html"
  },
  "7": {
    "id": "7",
    "title": "Filters",
    "content": "Filters Neuron’s query results might get narrowed by the filters. The github.com/neuronlabs/neuron/query/filters package contains all the necessary structures and methods that allows to specify what results we would like to obtain from the query. The filtering system used by Neuron is based on the model’s collection, field (optionally subfield), operator and the values. String Query Filter Filter Fields Operators String Query Filters The filter seperates the logic with the [, ] brackets. It consists of the collection, field, (optionally subfield), the operator and the values. The form of the string filter: filter[collection][field][$operator]=values filter[collection][relationship-field][field][$operator]=values filter[collection][relationship-field][related-field][field][$operator]=values ... The filter for the cars collection on field id with the value that is equal to 42 would look as follows: filter[cars][id][$eq]=42 In order to filter the field over it’s relationship values the relationship field must have it’s subfield defined within the filter i.e. in order to filter the cars collection over it’s relationship field driver - where the driver name is equal to Mark the following filter have to be applied: filter[cars][driver][name][$eq]=Mark In order to add the filter to the given scope use the AddStringFilter method to the query.Scope: if err = s.AddStringFilter(&quot;filter[cars][driver][name][$eq]&quot;, &quot;Mark&quot;); err != nil { // error occurs if the field doesn&#39;t exists panic(err) } If the query filter is on the different collection use the filters.NewStringFilter() method FilterField The second way to create a filter is to create the *filters.FilterField using the ModelStruct, it’s StructField, the *filters.Operator and the specific values. The package github.com/neuronlabs/neuron/query/filters contains the NewFilter function that is used to create the FilterField I.e. we want to create the filter to the cars collection query scope, that will filter the doors where it’s numbers is greater than or equal to 4 Then we should create it in a following way: Create the scope for the Cars field var c *Controller // Get the controller // we assume it is already created with the `Car` model var cars []*Car s, err := query.NewC(c, &amp;cars) if err != nil { panic(err) } Get the scope’s ModelStruct and the StructField we want in the filter. doorField, ok := s.Struct().Attr(&quot;doors&quot;) if !ok { panic(&quot;No doors field found&quot;) } Create and add new filter field // import &quot;github.com/neuronlabs/neuron/query/filters&quot; err = s.AddFilter(filters.NewFilter(doorField, filters.OpGreaterEqual, 4)) if err != nil { // the error might occur if the field is not found within the model&#39;s // struct field panic(err) } Operators Neuron implements the following basic filter operators: ID Name Query String Value Variable Name Description 1 Equal $eq *filters.OpEqual Matches values that are equal to the specified value 2 In $in *filters.OpIn Matches any values that are in the specified range of values` 3 Not Equal $ne *filters.OpNotEqual Matches values that are not euqal to the specified value 4 Not In $nin *filters.OpNotIn Matches any values that are not in the specified range of values 5 Greater Than $gt *filters.OpGreaterThan Matches any value that is greater than the specified value 6 Greater Than Equal $ge *filters.OpGreaterEqual Matches any value that is greater than or equal to the specified value 7 Less Than $lt *filters.OpLessThan Matches any value that is smaller than the specified value 8 Less Than Equal $le *filters.OpLessEqual Matches any value that is smaller than or equal to the specified value 9 Contains $contains *filters.Contains The operator used for the string variables, matches any values that contains the specified string value 10 Starts With $startswith *filters.StartsWith Used for the string variables, matches any values that starts with the specified string value 11 Ends With $endsswith *filters.EndsWith Used for the string variables, matches any values that ends with the specified string value 12 Is Null $isnull *filters.IsNull Matches all objects for which given field value is null 13 Not Null $notnull *filters.NotNull Matches all objects for which given field value is not null It is also allowed to have the custom operator, which might be used within the hooks and changed into the basic filters, or used in pair with the required handler for the specific repository. Custom Operators Neuron allows to use the custom operators. In order to use it The operator should be registered in the github.com/neuronlabs/neuron/query/filters package as well as in the repository on which it would be used. The custom operator should be created in the following way: Create new *filters.Operator object: myOperator := &amp;filters.Operator{Name: &quot;MyOperator&quot;, Raw:&quot;$my&quot;} The operator should have unique Name nad Raw fields. The Raw field should start with the ‘$’ dollar sign. Then the operator should be registered in the query filters: if err = filters.RegisterOperator(myOperator); err != nil { panic(err) } If we want to use this operator in the specified repostiory we should register it there as well (if the implementation allows it) - probably with the handler Otherwise the operator might be used within hooks and then replaced into the basic operators",
    "url": "http://localhost:4000/neuron-core/query/filters.html",
    "relUrl": "/neuron-core/query/filters.html"
  },
  "8": {
    "id": "8",
    "title": "Get",
    "content": "Getting Single Data The neuron specifies separate function for getting just a single data instance from the repository. In order to get the single data we need to provide a model pointer to the new query scope methods: var u User // create new query for the s := norm.MustNew(&amp;u) // s.Collection() == &#39;users&#39; Filters In order to get a single data we should provide a filter. // add the filter to the scope for user with id=4 err = s.AddStringFilter(&quot;filter[users][id][$eq]&quot;, 4) Fieldset By providing the fieldset we can define what fields we would like to get from the repository. err = s.SetFieldset(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;pets&quot;) Pagination If provided filters doesn’t specify the primary field key, the scope may contain also a pagination offset: limit, offset := 1, 10 // set the limit and offset err = s.Limit(limit, offset) If the limit is greater than 1 the results would still contain a single instance in Get method. Methods When the query is prepared use the Get or GetContext methods for the query to get a single data instance from the repository. err = s.GetContext(ctx) if err != nil { // handle the error } Relations If the fieldset contains any relationship field, the query processor would take it’s primary field key and store in the relationship field’s primary. fmt.Println(u.Pets) // []*Pets{{ID: 5}, {ID: 10}}",
    "url": "http://localhost:4000/neuron-core/query/get.html",
    "relUrl": "/neuron-core/query/get.html"
  },
  "9": {
    "id": "9",
    "title": "Mongo Repository",
    "content": "Mongo Repository",
    "url": "http://localhost:4000/neuron-mongo/",
    "relUrl": "/neuron-mongo/"
  },
  "10": {
    "id": "10",
    "title": "Query",
    "content": "Query Package: github.com/neuronlabs/neuron-core/query. Neuron-core’s architecture allows to query models with their relations located on separate databases, stores or services (Repositories). This requirement requires a lot of prices information about the given query. It’s structure is defined in the Scope which stores the parameters for each single query.",
    "url": "http://localhost:4000/neuron-core/query/",
    "relUrl": "/neuron-core/query/"
  },
  "11": {
    "id": "11",
    "title": "Errors",
    "content": "Errors The need to recognize the error types on the run, that might have different messages but the same meaning, was the cause to implement it’s own error classification system. Neuron provides it’s own error system, focused on the error meaning recognition.",
    "url": "http://localhost:4000/neuron-core/errors/",
    "relUrl": "/neuron-core/errors/"
  },
  "12": {
    "id": "12",
    "title": "Models",
    "content": "Models Package: github.com/neuronlabs/neuron-core/mapping Neuron used struct types with specific fields as the models. The model structure were based on the JSON:API v1.0 specification. It’s design distinguished fields by their kinds. This feature made it easier to isolate the model’s by their own repositories. Neuron maps each model, analyze it’s fields with tags and creates *mapping.ModelStruct. These models are registered in the Controller.",
    "url": "http://localhost:4000/neuron-core/models",
    "relUrl": "/neuron-core/models"
  },
  "13": {
    "id": "13",
    "title": "Core ORM",
    "content": "Core ORM Neuron-core is the golang cloud-native, distributed ORM implementation. What is Neuron Core? Install Quickstart Design Packages What is Neuron Core? Neuron-core is a cloud-ready Golang ORM. It’s design allows to query multiple related models located on different datastores/repositories. Install go get -u github.com/neuronlabs/neuron-core Quick Start Define the models package models // User is the model that is stored on the &#39;main&#39; repository. // It is related to multiple &#39;Pet&#39; models. type User struct { ID int Name string Surname string Pets []*Pet `neuron:&quot;type=relation;foreign=OwnerID&quot;` } // Pet is the model related with the User. // It is stored in the &#39;secondary&#39; repository. type Pet struct { ID int Name string OwnerID int `neuron:&quot;type=foreign&quot;` } // RepositoryName implements RepositoryNamer interface. func (p *Pet) RepositoryName() string { return &quot;secondary&quot; } Import repositories and Create, Read or get Default *config.Controller package main import( // blank imported repository registers it&#39;s factory // and the driver. _ &quot;github.com/neuronlabs/neuron-pq&quot; ) import ( &quot;github.com/neuronlabs/neuron-core/config&quot; &quot;github.com/neuronlabs/neuron-core&quot; ) func main() { cfg := config.ReadDefaultConfig() // By setting the LogLevel the default logger would be used. cfg.LogLevel = &quot;debug&quot; ... Create the *controller.Controller and register repositories. // Provided create config &#39;cfg&#39; to the Controller method. c := ncore.Controller(cfg) // As the &#39;neuron-core&#39; allows to use multiple repository for the models // we can declare the DefaultRepository within the config. The first // registered repository would be set as the default as well. mainDB := &amp;config.Repository{ // Currently registered repository &#39;neuron-pq&#39; has it&#39;s driver name: &#39;pq&#39;. DriverName: &quot;pq&quot;, Host: &quot;localhost&quot;, Port: &quot;5432&quot;, Username: &quot;main_db_user&quot;, Password: &quot;main_db_password&quot;, DBName: &quot;main&quot;, } if err := c.RegisterRepository(&quot;main&quot;, mainDB); err != nil { panic(err) } // We can register and use different repository for other models. secondaryDB := &amp;config.Repository{ DriverName: &quot;pq&quot;, Host: &quot;172.16.1.10&quot;, Port: &quot;5432&quot;, Username: &quot;secondary_user&quot;, Password: &quot;secondary_password&quot;, DBName: &quot;secondary&quot;, } // Register secondary repository. if err := c.RegisterRepository(&quot;secondary&quot;, secondaryDB); err != nil { panic(err) } Register models if err := c.RegisterModels(models.User{}, models.Pet{}); err != nil { panic(err) } Query registered models users := []*User{} s := ncore.MustQueryC(c, &amp;users) // the query scope may be filtered s.AddStringFilter(&quot;filter[users][name][$in]&quot;,&quot;John&quot;, &quot;Sam&quot;) // it might also be sorted s.SortBy(&quot;-id&quot;) // list all the users with the name &#39;John&#39; or &#39;Sam&#39; with &#39;id&#39; ordered // descending. if err = s.List(); err != nil { panic(err) } Packages The neuron-core is composed of the following packages: query - used to query the model’s repositories. controller - is the neuron’s core, that registers and stores the models and contains configurations required by other packages. mapping - contains the information about the mapped models their fields and settings config - contains the configurations structures. encoding/jsonapi - allows to marshal and unmarshal the model’s, and queries by the https://jsonapi.org/ specification errors - used as a default error package for the neuron packages. errors/class - contains errors classification system for the neuron packages repository - is a package used to store, get and register the repositories nad their factories. log - is the logging interface for the neuron based applications. i18n - is the neuron based application supported internationalization common - common neuron variables, functions and definitions.",
    "url": "http://localhost:4000/neuron-core",
    "relUrl": "/neuron-core"
  },
  "14": {
    "id": "14",
    "title": "Gateway",
    "content": "Gateway",
    "url": "http://localhost:4000/neuron-gateway/",
    "relUrl": "/neuron-gateway/"
  },
  "15": {
    "id": "15",
    "title": "Postgres Repository",
    "content": "Postgres Repository Neuron PQ is the Neuron-Core Postgres repository driver. It contains",
    "url": "http://localhost:4000/neuron-pq/",
    "relUrl": "/neuron-pq/"
  },
  "16": {
    "id": "16",
    "title": "Neuron",
    "content": "Neuronlabs The Neuron is the Golang based project with a scope to deliver top quality, cloud-native, microservice ready framework for building and creating services. Table of Contents Core Core Query Repositories",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "17": {
    "id": "17",
    "title": "Insert",
    "content": "Insert data In order to insert the data create a new query with the provided value: user := &amp;User{Name: &quot;Jack&quot;} s, err := query.New(user) if err != nil { return err } Any create query may have specified it’s Selected Fields. The selected fields are the field’s which values would be inserted into repository. By default the query processor scans provided scope.Value for non-zero field values and uses them as the selected fields. By specifing selected fields the query might insert zero-valued fields. err = s.SelectFields(&quot;Name&quot;, &quot;Age&quot;) if err != nil { return err } When the create query preparation is finished then the Create method should be used on the query.Scope. err = s.Create() OR with respect to the provided context.Context: ctx, cancel := context.WithTimeout(context.Background, time.Second * 5) defer cancel() err = s.CreateContext(ctx) If the query.Scope doesn’t have primary field selected then the repository should create new model instance and set it’s ID value into model’s primary field value. id := user.ID // newly created model&#39;s ID Relations While inserting the model, neuron allows to set the relations for given model within a single query. If the relationship field primary field(s) is non-zero then after having the root model value created, the following relationship field would have it’s relationship model’s patched with the selected foreign keys. user := &amp;User{Name: &quot;Thomas&quot;, Pets: []*Pet{ID: 5}} s, err = query.New(user) if err != nil { return err } // the Create query would create new user with name Thomas // and patch pets model&#39;s with id: &#39;5&#39; so that it&#39;s foreign key is set // to newly created user&#39;s id. err = s.Create() if err != nil { return err } Errors While patching the related values an error might occur. If the query was within a single transaction, then // possible strategies: transaction: rollback all changes of the query non transactions: return error - this should be done within a transaction - any change might provide continue WithTimeout error",
    "url": "http://localhost:4000/neuron-core/query/insert.html",
    "relUrl": "/neuron-core/query/insert.html"
  },
  "18": {
    "id": "18",
    "title": "List",
    "content": "Listing data Listing the data is one of the most important ORM functions. Neuron allows to query along multiple repositories joining efficiently all the relations. By default while getting the relation data, neuron gets only relationship’s primary id’s. Prepare query scope Creating a List Query requires to provide an address of slice of models, to the query.New, query.NewC, query.MustNew, query.MustNewC functions: users := []*User{} s, err := query.New(&amp;users) Having prepared the query scope, we can specify what data we would like to obtain. // add the field filter if err = s.AddStringFilter(&quot;filter[users][id][$ne]&quot;, 51); err != nil { return err } limit := 5 offset := 12 // limit the values number at specific offset if err = s.Limit(limit, offset); err != nil { return err } // Set the return field set if err = s.SetFieldset(&quot;name&quot;, &quot;pets&quot;); err != nil { return err } // sort by the primary field in a decreasing order if err = s.SortBy(&quot;-id&quot;); err != nil { return err } Such prepared query Scope is ready for processing. The List or ListContext are the methods reponsible to list all the specified data instance from the repositories. // if we have a context we need to include into consider use ListContext method // otherwise choose List. if err = s.List(); err != nil { return err } // now the scope value - variable &#39;users&#39; should contain // the required values. As a result the arguments provided while creating the query scope would contain the data instances taken from repositories. If no data would be find for given query an error of class class.QueryValueNoResult would be returned. // use previously prepared query scope to list the data values err = s.List() if err != nil &amp;&amp; !errors.IsNoResult(err) { return err }",
    "url": "http://localhost:4000/neuron-core/query/list.html",
    "relUrl": "/neuron-core/query/list.html"
  },
  "19": {
    "id": "19",
    "title": "Pagination",
    "content": "Pagination The neuron allows to reduce the number of the given list results. It provides the pagination system, on the LimitOffset or Page base. Limit Offset The LimitOffset pagination type is well known from SQL. It limits the number of object with the Limit value and Offset says to skip as many objects from the current model’s results. // Let&#39;s limit the results up to lenght of 10 starting from the fifth + 1 limit, offset := 10, 5 err = scope.Limit(limit, offset) // an error might occur if the pagination is already set for the scope. Page Page based pagination uses PageSize and PageNumber variable to define the result. Each page should have results of size: PageSize, and have it’s PageNumber index. PageSize defines the number of objects to return. PageNumber is the index of current page. If each page contains: PageSize of objects, page number defines how many values should be skipped in the result. // Get results of page size &#39;20&#39; by skipping one page number (starting from // the &#39;2&#39; pageNumber. pageNumber, pageSize := 2, 20 // an error might occur if the pagination is already set on the query&#39;s scope. err = scope.Page(pageNumber, pageSize)",
    "url": "http://localhost:4000/neuron-core/query/pagination.html",
    "relUrl": "/neuron-core/query/pagination.html"
  },
  "20": {
    "id": "20",
    "title": "Patch",
    "content": "Patching single data The neuron allows to patch provided data instances in the repositories. It changes selected fields for the provided data model instance. Firstly the query scope needs to be created: // prepare the model data instance u := User{ // Primary key ID: 5, // Attribute Name: &quot;Anthony&quot;, // Relationship Pets: []*Pet{{ID: 5},{ID: 12}}, } // create new query scope for the &#39;u&#39; User. s := norm.MustNew(&amp;u) Fitler In order to patch, the query processor requires that the query scope must have any kind of filter. While providing the data with non zero primary key field, neuron processor would take it’s value and set as the primary key filter with $eq filter operator. Validation Each patching data might be validated before the operation starts. The validation is done by the gopkg.in/go-playground/validator.v9 validator. The default patch validator might be changed by setting controller’s PatchValidator. Selected Fields It is worth to emphasize that the Patch updates only the Selected fields. If no selected fields are provided for the query scope, the query processor would take all the non-zero values of the provided model. If we want to change the field’s value to it’s zero value i.e.: // Part is the example model containing zero-value attribute fields. type Part struct { ID int Price int Amount int } // set the model with it&#39;s primary key equal to &#39;1&#39; p := Part{ID: 1} // we want to patch the amount to &#39;0&#39; s := query.MustNew(&amp;p) // in order to use the &#39;Amount&#39; field it must be marked as selected. err = s.SelectField(&quot;Amount&quot;) if err != nil { // error might occur on misspeling the field name } Patching Methods When the query scope is ready for patching, use the query scope’s methods: Patch or PatchContext if the query should be based on the context.Context. err = s.Patch() if err != nil { // handle the patch error } Relations When the query scope has selected the relationship field the patch would change their values depending on the relationship type and field’s value. In future versions of the Core ORM each relationship would have it&#39;s change strategy. The strategy would differ the processes on data patching, depending on the user&#39;s choice. BelongsTo relationship In BelongsTo relationship the root model contains related foreign key for the relationship. If the selected relationship field would be a non nil, the processor copies it’s related primary field key into related foreign key. If it’s nil it would set it’s foreign key to zero value. HasOne relationship For models with selected HasOne relationship field, if it’s value is: non-zero model instance - then the processor would patch the related model’s foreign key. nil value - the processor clears the related model’s foreign key by setting it to zero-value. HasMany relationship For models with selected HasMany relationship field, if it’s value is: non-zero multi model instances - the processor clears old related models foreign keys and sets current related models foreign key field to the root model primary key field value. empty slice - the processor clears previous related model’s foreign keys that were equal to the root model’s primary key field value. ManyToMany relationship For models with selected Many2Many relationship field, if it’s value is: non-zero multi model instances - the processor clears old related models foreign keys in the join model and sets current related models foreign key field in the join model to the root model primary key field value. empty slice - the processor clears previous join model’s data instances where the foreign key is equal to the model’s primary key field value.",
    "url": "http://localhost:4000/neuron-core/query/patch.html",
    "relUrl": "/neuron-core/query/patch.html"
  },
  "21": {
    "id": "21",
    "title": "Processor",
    "content": "Query Processor",
    "url": "http://localhost:4000/neuron-core/processor.html",
    "relUrl": "/neuron-core/processor.html"
  },
  "22": {
    "id": "22",
    "title": "Relationships",
    "content": "Relationship Relationship is the structure that contains information about the relationship field for given model. It defines information such that: Kind - defines the relationship kind ForeignKey - is the struct field that defines relationship’s foreign key Join Model - (optional) used only for the ManyToMany models as the join model definition. ManyToManyForeignkey - (optional) is the foreign key used on the ManyToMany relationship that defines related model’s foreign key within the JoinModel Struct - defines the related model structure.",
    "url": "http://localhost:4000/neuron-core/models/relationship.html",
    "relUrl": "/neuron-core/models/relationship.html"
  },
  "23": {
    "id": "23",
    "title": "Repositories",
    "content": "Repositories Neuron-core use the repositories as the database/data store/service access. The main abstractions of the repositories are repository.Factory and a repository.Repository. Factory The Factory is the abstraction used to create new repository instances. It is also responsible for keeping the instances and closing them. Each factory have a unique driver name, which is used by the repositories configurations (*config.Repository) and by the *controller.Controller which is responsible to get the appropiate factory and create new repository instances for the models. The Factory should be registered within the neuron-core on package initialization. Custom factory skeleton may look like in the following example: package myfactory import ( &quot;context&quot; &quot;github.com/neuronlabs/neuron-core/mapping&quot; &quot;github.com/neuronlabs/neuron-core/repository&quot; ) // this factory should be registered on the blank import. func init(){ // this factory would be registered with the driver name // defined as in the factory &#39;DriverName&#39; method. if err := repository.RegisterFactory(&amp;Factory{}); err != nil { panic(err) } } // the Factory must implement repository.Factory interface. var _ repository.Factory = &amp;Factory{} // Factory is the neuron repository.Factory implementation // of the custom repository factory. // Implements repository.Factory. type Factory { instances []*Repository ... } // DriverName implements repository.Factory interface. func (f *Factory) DriverName() string { return &quot;myfactory&quot; } // New implements repository.Factory interface. func (f *Factory) New(c repository.Controller, model *mapping.ModelStruct) (repository.Repository, error) { // Do the logic and create (or use existing) repository instance. } // Close implements repository.Factory interface. func (f *Factory) Close(ctx context.Context, done chan&lt;-interface{}) { for _, instance := range f.instances { if err := instance.Close(ctx); err != nil { // handle the error } } // send the information that it finished the closing methods. done &lt;- struct{} } The repository.Factory is an interface used to create new instances of the repository.Repository. This interface requires to implement three methods: DriverName() - which gets the unique driver name for the given factory. New(c Controller,model *mapping.ModelStruct) (repository.Repository, error)- create new instance of the repository for given ‘model’. The Controller argument is an interface for the controllers that is used to get model structures. If the Repositories share similar connection configuration it may use the existing instance instead of creating new. The model specific repository configuration are obtainable by using model.Config().Repository Close(context.Context, done chan&lt;-interface{}) closes all the instances of the factory related repositories. Repository The Repository is the abstraction used to get the access to the data/service. It may be a used as the ORM access to the database, http.Client to some external service or just a custom accessability by using provided interfaces. The repository.Repository is the basic and required interface for the all the repository implementaions. The Repository instances should be created by it’s specific Factory. While registering the models, the controller stores the mapping between repositories and related models. All the Repository methods should not be used by the user directly. In order to access the data or service the Repository may implement specific interfaces defined in the query package like: Creator - creates and stores new instances of the model. Getter - gets a single instance of the specific model. Lister - lists multiple instances of the given model. Patcher - patches only selected model’s value. Deleter - deletes the model instances. Transactioner - allows to use the transactions. Creator func (r *Repository) (ctx context.Context, scope *query.Scope) error { // Do the create logic here return nil } The Create method of the Creator interface requires the Repository to create a specific model instance. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. Provided ‘scope’ structure contains multiple important information about given query like: scope.Value - scope.Value contains the model instance in a pointer to struct type. SelectedFields() - fields used in the current query.Scope. Only these fields should be stored by this query. It might be useful if a user would like to select and store the zero value fields. If the primary field is not selected, then the Repository should generate new primary field value and set it to the model’s scope.Value instance. Struct() - gets *mapping.ModelStruct for the specific query. The model structure has information about all it’s fields. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). Getter and Lister Getter func (r *Repository) Get(ctx context.Context, scope *query.Scope) error { // Do the get logic here return nil } Lister func (r *Repository) List(ctx context.Context, scope *query.Scope) error { // Do the logic here return nil } Both Get method from the Getter and List from the Lister interface should get a specific model instances for provided query ‘scope’. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. The get method must not return more than one value instance - (scope.Value is a pointer to the model struct). In order to narrow the scope of the query the *query.Scope contains multiple important information like: PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. Fieldset() - fieldset is a set of fields returned for each model for given query. Pagination() - a pagination paramters for given query. Get method must always return a single value, even if the pagination is limited to more than one result. scope.Value - the value where the results should be stored. It’s instance is already initialized and must not be overwritten. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If there no resultant value was found in related datastore/database then the repository should return an error with no result error classification. Patcher func (r *Repository) Patch(ctx context.Context, scope *query.Scope) error { // Do the patch logic here return nil } The Patch method from the Patcher interface should patch models with the values provided by the ‘scope’. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. Provided scope contains a single value instance with specific field values, with related filters used to narrow the query. The patch should update only the fields defined in the scope’s selected fields. Useful parameters stored in the scope: scope.Value - the value where the field’s values are stored. It’s instance is already initialized and must not replaced with new model’s instance. PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. SelectedFields() - fields used in the current query.Scope. Only these fields should be used by this query. It might be useful if a user would like to select and store the zero value fields. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If there no resultant value was found in related datastore/database then the repository should return an error with no result error classification. Deleter func (r *Repository) Delete(ctx context.Context, scope *query.Scope) error { // Do the delete logic. return nil } The Delete method from the Deleter interface should delete all the matching model instances defined by the given query scope. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. The scope should contain all the required filters: PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If no values were affected with given query then the repository should return an error with no result error classification. Transactioner The Transactioner interface requires the Repository to implement transactions for the specific queries. The transaction’s should be isolated for the specific Repository (the single repository might be used for multiple models with the same database). The scope has a Tx() method which returns the scope’s transaction structure. This structure contains the Transaction type and it’s unique ID - this value should be used to map the transaction instances. Begin func (r *Repository) Begin(ctx context.Context, scope *query.Scope) error { // Begin the transaction return nil } The Begin method should begin the repository specific transaction. In order to follow up the transactions the Repository on Begin should store related transactions ‘id’ with it’s specific structures - i.e. sql.Tx as well as Begin a transaction on it’s store/database. The transaction should be created with the specific ‘ctx’ context. Commit func (r *Repository) Commit(ctx context.Context, scope *query.Scope) error { // Commit the transaction changes return nil } If the query resulted with no error then the transaction should be commited. The Commit method allows to apply the transaction changes and remove the mapping transaction mapping. Rollback func (r *Repository) Rollback(ctx context.Context, scope *query.Scope) error { // Rollback any changes made by the transation. return nil } If the transaction were rolled back then the Rollback should undo the changes made within given transaction, and remove the transaction mapping. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`).",
    "url": "http://localhost:4000/neuron-core/repositories.html",
    "relUrl": "/neuron-core/repositories.html"
  },
  "24": {
    "id": "24",
    "title": "Scope",
    "content": "Scope Scope is the data structure that contains all the information about given query. It keeps the information about the filtering, sorting, pagination, fieldset, selected fields, value and many other meta data. Each of it is accessible from the *query.Scope instance as the methods or variables: ID - unique query id number (UUID) Value - Query’s value defines the values to be returned (GET and LIST), created (CREATE), changed (PATCH) or deleted (DELETE). Filters - query filters divided by the field types Primary Key filters Foreign Keys filters Attribute filters Relationship filters Filter Keys filters Fieldset - set of fields that must be returned with their values from the repository Selected Fields - set of fields selected to create/change any repository model Sorting Order - sorting order of the query Pagination - query paginations How to create a query Scope? A query scope can be created from the root github.com/neuronlabs/neuron-core or the github.com/neuronlabs/neuron-core/query package. In order to create a new Scope, it’s valid root model must be provided as well as the controller that keeps related models. Create with value A scope might be create with model value using ncore.Query, ncore.QueryC, ncore.MustQuery or ncore.MustQueryC. The functions with the ‘C’ ending requires the controller to be provided as the argument, whereas the other use default controller. Example Must: m := &amp;Model{ID: 3} // This function creates new scope with the default controller and // the model &#39;m&#39;. It panic on error. scope := ncore.MustQuery(m) Example QueryC: // supposed that we have already a controller &#39;c&#39; with registered &#39;Model&#39;. m := &amp;Model{ID: 2, Name: &quot;Anthony&quot;} // This takes the &#39;c&#39; controller and the model &#39;m&#39;. // Returns error if the model&#39;s value is not valid. scope, err := ncore.QueryC(c, m) These queries might be also created using direct access to the github.com/neuronlabs/neuron-core/query with methods such as: query.New, query.NewC, query.MustNew, query.MustNewC. The functions with ‘C’ endings requires the controller.Controller to be provided as argument, whereas the others would use the Default Controller. Scope allowed Values The scope keeps two types of values: single instance - it is a non-nil pointer to the value model. multiple instances - a non-nil pointer to the slice of pointers to models. Examples: single := Model{ID: 5} many := []*Model{{ID: 3}} // This would be correctly created scope - the value taken is an // address of model/slice instances. scope := query.MustNew(&amp;single) scope2 := query.MustNew(&amp;many) // This two would panic, the value taken are not pointers to the structures. scope = query.MustNew(single) scope = query.MustNew(many) Create scope with *ModelStruct The query might be also created using a *ModelStruct with the package github.com/neuronlabs/neuron-core/query. The method query.NewModelC is used to create scope with the ModelStructure. It requires controller to be provided as an argument, as well as information if the value of the query should be a slice or a single value instance isMany boolean. Created scope’s values would depend on the isMany flag, and their types would looks like: isMany - true - *[]*Type{} isMany - false - *Type{} Where the Type is the model registered in the controller. Example: // supposed that the controller &#39;c&#39; was previously // created with registered model &#39;Model&#39;. mStruct, _ := c.ModelStruct(Model{}) scope := query.NewModelC(c, mStruct, true) var many []*Model // scope&#39;s Value is a non-nil pointer of slice of pointer models temp := scope.Value.(*[]*Model) // dereference the pointer to get the slice of models. many = *temp",
    "url": "http://localhost:4000/neuron-core/query/scope.html",
    "relUrl": "/neuron-core/query/scope.html"
  },
  "25": {
    "id": "25",
    "title": "Selected Fields",
    "content": "Selected Fields For the queries where the provided input model would have usable values, the selected field defines are the fields that should be used by the processor. By default - (if no fields were selected for the query) all non-zero valued fields would be added to the query’s Selected Fields. If the zero-valued field should be used, it needs to be added to the query’s Selected Fields. JSONAPI It is also used by the encoding/jsonapi package. While unmarshaling the scope with specified values it selects only unmarshaled fields from the input data. Selected Fields methods The query allows to do multiple operations on the given scope. It allows to check what fields are selected, return all non selected fields, select single or multiple fields. Prepare the query scope: // User is the neuron model used for the purpose of this documentation. type User struct { ID int Name string `neuron:&quot;name=custom_name&quot;` Age int PhoneNumber string } // create model instance user := User{ID: 1, Name: &quot;Miguel&quot;, Age: 17} // scope := MustNew(&amp;user) IsSelected is selected checks if the provided argument ‘field’ is selected within the query’s scope. The field might be a string struct field Name, Neuron Name or a *mapping.StructField. // In order to check if the field is selected the function allows us to use multiple &#39;field&#39; types: // 1. StructField Name isNameSelected, err := scope.IsSelected(&quot;Name&quot;) // 2. Neuron Name isNameSelected, err = scope.IsSelected(&quot;custom_name&quot;) // 3. *mapping.StructField field, _ := s.Struct().FieldByName(&quot;Name&quot;) isNameSelected, err = scope.IsSelected(field) SelectField Selects the field in the scope’s query. The ‘field’ must be a string structfield’s Name or Neuron Name. // the err := scope.SelectField(&quot;Age&quot;) err = scope.SelectField(&quot;custom_names&quot;) SelectFields Works adds multiple fields to the query scope’s selected fields. The field might be a string struct field Name, Neuron Name or a *mapping.StructField. // Each field may be of different type phoneNumber, _ := scope.Struct().FieldByName(&quot;PhoneNumber&quot;) err = scope.SelectFields(&quot;Age&quot;, &quot;custom_names&quot;, phoneNumber) SelectedFields Lists all the selected fields in the query’s scope. Returns []*mapping.StructField. var selectedFields []*mapping.StructField selectedFields = scope.SelectedFields() NotSelectedFields Lists all the fields that were not selected in the query’s scope. Returns []*mapping.StructField. var notSelectedFields []*mapping.StructField notSelectedFields = scope.NotSelectedFields()",
    "url": "http://localhost:4000/neuron-core/query/selected_fields.html",
    "relUrl": "/neuron-core/query/selected_fields.html"
  },
  "26": {
    "id": "26",
    "title": "Sorts",
    "content": "Sorts Neuron allows to sort the List method results. The sorting is based on the provided field’s value. It allows both ascending and desceding ordering. NOTE: Current implementation allows sorting by the fields of the query scope&#39;s root model only. Scope Sorting By default scope sorts by the primary field values in ascending order. In order to sort the results by other fields, SortBy scope method should be used. The function takes multiple string ‘fields’ as an arguments. By default each sort field would be in ascending order. In order to change it into descending order the - sign should be used before given ‘field’. Example: // Sort the scope&#39;s result by the name, and if that matches sort by the age in // desceding order. err = scope.SortBy(&quot;name&quot;, &quot;-age&quot;) This would result in sorting the results by the name. In case multiple fields would match, these would be sorted by the age in desceding order.",
    "url": "http://localhost:4000/neuron-core/query/sorts.html",
    "relUrl": "/neuron-core/query/sorts.html"
  },
  "27": {
    "id": "27",
    "title": "Structure",
    "content": "Model Structure The *ModelStruct is a data structure that stores all prepared information about the ‘model’. This document would base it’s examples on the provided models: // Bird is the neuron model used for the documentation. // It&#39;s fields have cardcoded neuron types. type Bird struct { ID int `neuron:&quot;type=primary&quot;` Name string `neuron:&quot;type=attr&quot;` Age int `neuron:&quot;type=attr&quot;` Specie *BirdSpecie `neuron:&quot;type=relation&quot;` BirdSpecieID int `neuron:&quot;type=foreign&quot;` } // BirdSpecie is the neuron model used for the documentation. // It defines the birds species. type BirdSpecie struct { ID int Name string } A model stores following variables: Type - specified reflect.Type that is dereferenced model type reflection. Collection - pluralized name converted using Controller&#39;s NamerFunc. Config - is the *config.Model matched for given model. Store - is the key:value storage for given model. Primary Key Field - is the *mapping.StructField of the model’s primary index field. Attribute Fields - (optional) model may contain multiple *mapping.StructField attributes. An attribute is the non related information about the model stored directly in the model’s repository. Relationship Fields - (optional) relationship fields represents references to the other models stored as struct fields. ForeignKey Fields - (optional) foreign keys are the fields directly connected with the relationship. It defines matched primary key of the related field’s model. Language Field - (optional) is a singleton (per model), optional field that defines lanaguage and i18n related values. Filter Key Fields - (optional) filter key fields are the fields which values are not stored within the model’s repository. Their value should be used to specify some state that might be usable in the Hooks. Registering Models Neuron requires to register the model before any operation starts. Registering model, stores it’s *mapping.ModelStruct in the Controller. A controller can have only a single model related to each reflect.Type and a single collection. Register the models with the RegisterModels Controller&#39;s method. It takes the model value instances as arguments. If a model have relationship fields, all the related models must be registered at once. The order of the provided models doesn’t matter. err := c.RegisterModels(Bird{}, BirdSpecie{}) if err != nil { // the model definition is invalid. return err } Getting Model Struct Having our models registered, we might want to use it’s mapping structure. This would be done by the Controller&#39;s ModelStruct method: modelStruct, err := c.ModelStruct(Bird{}) if err != nil { // the model is not found within given controller. return err }",
    "url": "http://localhost:4000/neuron-core/models/structure.html",
    "relUrl": "/neuron-core/models/structure.html"
  },
  "28": {
    "id": "28",
    "title": "Transactions",
    "content": "Transactions Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Begin Commit Rollback Begin Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Commit Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum. Rollback Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
    "url": "http://localhost:4000/neuron-core/transactions.html",
    "relUrl": "/neuron-core/transactions.html"
  }
  
}
