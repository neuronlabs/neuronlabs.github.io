{
  "0": {
    "id": "0",
    "title": "Class",
    "content": "Comparing errors Standard golang errors are mostly compared by their messages. But what if we have multiple errors with the same logic meaning but different messages? This issue is solved by the Class abstraction. Class definition The package defines blazingly fast classification system. A Class is an uint32 wrapper, composed of the Major, Minor and Index subclassifications. Each subclassifaction has different bitwise length. A major is composed of 8, minor 10 and index of 14 bits - total 32bits. Example: Class with decimal value of 44205263, in a binary form equals to 00000010101000101000010011001111 which decomposes into: 00000010 - major (8 bit) 1010001010 - minor (10 bit) 00010011001111 - index (14 bit) The class concept was inspired by the need of multiple errors with the same logic but different messages. Major It is an uint8 wrapper that store major error subclassification. Create with NewMajor or MustNewMajor functions There might be at most 256 unique Majors. Minor A minor a is mid-level error subclassification. It is a uint16 wrapper. It stores a maximum of 10 bit variable. Each Major may contain 1024 unique minors. Create using NewMinor or MustNewMinor functions. Index An index is the lowest level error subclassification. It is a uint16 wrapper, with a maximum of 14 bit value. Each Minor may contain 16384 unique indexes. Create using NewIndex or MustNewIndex functions. New Classes A class might be composed in three different ways: Major only - the class is Major singleton. Major, Minor only - classes that don’t need triple subclassification divison. Major, Minor, Index - classes that decomposes.",
    "url": "http://localhost:4000/errors/class.html",
    "relUrl": "/errors/class.html"
  },
  "1": {
    "id": "1",
    "title": "Config",
    "content": "Config While registering the models, each ModelConfig defined under model’s collection in the Controller&#39;s ` Config would be set in the ModelStruct` definition. It’s RepositoryName value defines to which repository should the model be connected. The Store field is being copied to the model’s store values. This allows to specify repository related variables. The AutoMigrate flag is the information to the repository if the model should be migrated within the repository (database tables etc).",
    "url": "http://localhost:4000/neuron-core/models/config.html",
    "relUrl": "/neuron-core/models/config.html"
  },
  "2": {
    "id": "2",
    "title": "Controller",
    "content": "Controller Package: github.com/neuronlabs/neuron-core/controller Controller is the structure used by the neuron-core that contains all the application context relation data. The *controller.Controller contains most important variables used by all the packages in neuron-core. It contains mappings - model to structures, model to repository; model definitions, repositories and the configurations. Package Repositories Models Create Controller In order to create and set new controller use the New or MustNew method with the provided config. package main import ( &quot;github.com/neuronlabs/neuron-core/config&quot; &quot;github.com/neuronlabs/neuron-core/controller&quot; ) var cfg *config.Controller func main() { // Read the config // cfg = ReadConfig() c, err := controller.New(cfg) // if the config is not valid the function would return an error. // on the other hand creating the config with MustNew would panic on error. c2 := controller.MustNew(cfg) } Repositories The neuron-core uses the abstraction of the repository.Repository as a data source. Controller registers and stores them, so that the related models might use their data access. Register Repository The repositories might be stored and registered in two ways: With the Controller Config By using RegisterRepository Controller method The repository configurations provided with the Controller Config would be registered while createing the New Controller. The RegisterRepository allows to store manually the *config.Repository for the given ‘name’ within given Controller. Example: cfg := &amp;config.Repository{ Username: testing, Password: testing, DBName: testing1, Port: 5432, Host: localhost, } err = c.RegisterRepository(&quot;my_repository&quot;, cfg) In the example above the following Repository config is stored under the ‘my_repository’ key. All the model’s that are mapped with the ‘my_repository’ Repository, would use the Factory repository credentials shown above. Models Mapping Controller is used to register the models. This creates *mapping.ModelStruct for each model, which have a mapping of the fields Registering Models Model register process should begin only when the related Repositories are already registered. Each model after being mapped, gets their related Repository created by it’s Factory for it’s Model mapping In order to have an model mapping the models needs to be registered within the controller: var c *controller.Controller c := controller.MustGetNew(cfg) err := c.RegisterModels(Model{}, User{}, Dog{}, Cat{}) ...",
    "url": "http://localhost:4000/neuron-core/controller.html",
    "relUrl": "/neuron-core/controller.html"
  },
  "3": {
    "id": "3",
    "title": "Delete",
    "content": "Deleting data Deleting the data instances is based on the query scope filters. Create new query scope for the model that would be deleted: // we want to delete the users collection&#39;s instance with id: &#39;4&#39; u := User{ID: 4} // prepare the query scope s := norm.MustNew(&amp;u) Filters In order to delete the data model’s instance we need to provide query scope filters. If the model provided in the query creation method contains non-zero primary field value, the neuron processor sets it’s value to scope’s primary filter. Deleting Methods When the query scope is ready for deleting, use the query Scope’s methods: Delete or DeleteContext if the query should be based on the ‘context.Context’. err = s.Delete() if err != nil // a different logic may be provided for specified error. // If no values were deleted the processor returns errors with class // QueryValueNoResult. if !errors.IsNoResult(err) { return err } } Relations While deleting current data instance the processor clears also related relationship foreign keys. In future versions of the Core ORM each relationship would have it&#39;s change strategy. The strategy would differ the processes on data deletion, depending on the user&#39;s choice. BelongsTo In BelongsTo relationship the root model contains a foreign key which would be deleted with the model indstance. HasOne The models with HasOne relationships would have related model’s foreign keys deleted. HasMany The models with HasMany relationships would have related model’s foreign keys deleted. ManyToMany The models with Many2Many relationships would have related model’s foreign keys deleted from the join model.",
    "url": "http://localhost:4000/neuron-core/query/delete.html",
    "relUrl": "/neuron-core/query/delete.html"
  },
  "4": {
    "id": "4",
    "title": "Error Interfaces and Structs",
    "content": "Interfaces The package provides simple error handling interfaces and functions. It allows to create simple and detailed classified errors. ClassError A ClassError is the interface that provides error classification with theClass method. DetailedError DetailedError is the interface used for errors that stores and handles human readable details, contains it’s instance id and runtime call operation. Implements ClassError, Detailer, Operationer, Indexer, error interfaces. Detailer Detailer interface allows to set and get the human readable details - full sentences. Operationer OperationError is the interface used to get the runtime operation information. Indexer Indexer is the interface used to obtain ID() for each error instance. Error handling This package contains two error structure implementations: Simple Error Structure Detailed Error Structure Simple Error Structure A simple error implements ClassError interface. It is lightweight error that contains only a message and it’s class. Created by the New and Newf functions. err := New(ClMyCustomClass, &quot;error message&quot;) err := Newf(ClMyCustomClass, &quot;formatted: %s&quot;, &quot;error message&quot;) Detailed Error Structure The detailed error struct (detailedError) implements DetailedError. It contains a lot of information about given error instance: Human readable Details Runtime function call Operations Unique error instance ID In order to create detailed error use the NewDet or NewDetf functions. err := NewDet(ClMyCustomClass, &quot;detailed error structure message&quot;)= err.SetDetails(&quot;My custom human readable details&quot;) err := NewDetf(ClMyCustomClass, &quot;detailed error structure, formatted: %s&quot;, &quot;error message&quot;) err.SetDetailsf(&quot;My custom human readable formatted details: &#39;%s&#39;&quot;, &quot;Message&quot;)",
    "url": "http://localhost:4000/errors/errors.html",
    "relUrl": "/errors/errors.html"
  },
  "5": {
    "id": "5",
    "title": "Fields",
    "content": "StructField A *mapping.StructField is the mapped model’s field. It contains neuron information about given field, such as: ModelStruct - the model where the field is defined Neuron Name - is the field’s name converted using controller’s defined NamerFunc. Name - the structField’s Name. FieldKind - is the neuron kind of the field: Primary Key - the primary key field of the model Foreign Key - the foreign key field for the model’s relationship Attribute - an attribute of the model RelationshipSingle - single value relationship field RelationshipMultiple - multiple value relationship field Filter Key - a key value used to change the hooks Nested - for the nested attributes Nested - nested structure for the nested field types. Relationship - relationship contains information about the field’s relation to another model. ReflectField - is the reflect.StructField reflection Store - is the key:value storage for given field. Field Tags In order to specify field’s specifictaion each field may be tagged with some specific tag. The basic struct tag is named: neuron. Under this tag there might be multiple tags seperated with ; sign. Each tag may take additional key=value seperated with ,. Fields tagged with - would not be mapped into neuron structures. Example: type TestingModel struct { ID string `neuron:&quot;type=primary&quot;` Name string `neuron:&quot;type=attr;flags=omitempty,nosort&quot;` NonNeuronField int `neuron:&quot;-&quot;` } // ID field has a neuron tags: `type` with value `primary` // Name field has tags: // - &#39;type&#39; with value &#39;attr&#39; - Attribute field // - &#39;flags&#39; with values seperated by &#39;,&#39; - &#39;omitempty&#39; and &#39;nosort&#39;. // NonNeuronField has tag: &#39;-&#39; which defines that // this is not a neuron field, omit and don&#39;t map it. Tags: Tag Description Requirements name Define the name of the field   type Define the field type   foreign Define the name(‘s) for the foreign key(‘s) for given relationship Relationship many2many Defined given field as Many2Many relationship. If the values are provided, the first would be a foreign key and the second - related model’s foreign key. ToMany Relationship flags Struct field tag that allows to store the field’s flags - - Omits given field in mapping process   Flags Field’s flags changes the field’s definitions. They’re defined in the struct field’s tag under neuron-&gt;flags tag. It is also allowed to specify flags within the Field’s Config store. Flag Description Requirements client-id Defines if the provided field allows to create new model instances with user defined ID values Primary Key Field nofilter Disallow to filter the model by given field   nosort Disallow to sort the model by given field   omitempty encoding/jsonapi would omit this field if it’s value is empty   hidden encoding/jsonapi would not marshal this field   lang given field is a language type field Attribute, Singleton in given Model iso8601 Is the marshaling and unmarshaling information about the format of given time field Time field Field Types Tags Allowed field type tags: Tag Description primary, primary_key, primarykey, id, pk primary key field definitions attr, attribute Attribute fields type relation, relationship Relationship field types foreign, foreign_key, foreignkey, fk Foreign key type definiton filterkey Filter Key type definition",
    "url": "http://localhost:4000/neuron-core/models/field.html",
    "relUrl": "/neuron-core/models/field.html"
  },
  "6": {
    "id": "6",
    "title": "Fieldset",
    "content": "Fieldset Query fieldset defines the fields that would be returned with the query resutls. It is used on results of Get and List methods. If no fields in fieldset were specified for the query, the processor would add all the possible model’s fields. While listing multiple values or querying over the relationships it might significantly increase the query speed. JSONAPI The package encoding/jsonapi uses fieldset in MarshalScope functions. It defines which attributes and relationships should be marshaled into output data. Fieldset Methods The *query.Scope provide following methods for the access to the fieldset: SetFields Adds ‘fields’ to the fieldset of the scope. Each field might be a string struct field Name, Neuron Name or a *mapping.StructField. Returns error if the field is not found within the query scope root model. err := scope.SetFields(&quot;Name&quot;, &quot;custom_neuron_name&quot;) List Fieldset Fieldset method returns all the fields in the scope’s Fieldset. The returned fields are: []*mapping.StructField. var fieldset []*mapping.StructField fieldset = scope.Fieldset() In Fieldset The InFieldset method checks if provided field is in the scope’s Fieldset. The ‘field’ might be a StructField Name or a Neuron Name. isInFieldset, err := scope.InFieldset(&quot;Name&quot;)",
    "url": "http://localhost:4000/neuron-core/query/fieldset.html",
    "relUrl": "/neuron-core/query/fieldset.html"
  },
  "7": {
    "id": "7",
    "title": "Filters",
    "content": "Filters Neuron’s query results might get narrowed by the filters. The github.com/neuronlabs/neuron/query/filters package contains all the necessary structures and methods that allows to specify what results we would like to obtain from the query. The filtering system used by Neuron is based on the model’s collection, field (optionally subfield), operator and the values. String Query Filter Filter Fields Operators String Query Filters The filter seperates the logic with the [, ] brackets. It consists of the collection, field, (optionally subfield), the operator and the values. The form of the string filter: filter[collection][field][$operator]=values filter[collection][relationship-field][field][$operator]=values filter[collection][relationship-field][related-field][field][$operator]=values ... The filter for the cars collection on field id with the value that is equal to 42 would look as follows: filter[cars][id][$eq]=42 In order to filter the field over it’s relationship values the relationship field must have it’s subfield defined within the filter i.e. in order to filter the cars collection over it’s relationship field driver - where the driver name is equal to Mark the following filter have to be applied: filter[cars][driver][name][$eq]=Mark In order to add the filter to the given scope use the Filter method to the query.Scope: if err = s.Filter(&quot;filter[cars][driver][name][$eq]&quot;, &quot;Mark&quot;); err != nil { // error occurs if the field doesn&#39;t exists } FilterField The second way to create a filter is to create the *filters.FilterField using the ModelStruct, it’s StructField, the *filters.Operator and the specific values. The package github.com/neuronlabs/neuron/query/filters contains the NewFilter function that is used to create the FilterField I.e. we want to create the filter to the cars collection query scope, that will filter the doors where it’s numbers is greater than or equal to 4 Then we should create it in a following way: Create the scope for the Cars field var c *Controller // Get the controller // we assume it is already created with the `Car` model var cars []*Car s, err := query.NewC(c, &amp;cars) if err != nil { panic(err) } Get the scope’s ModelStruct and the StructField we want in the filter. doorField, ok := s.Struct().Attr(&quot;doors&quot;) if !ok { panic(&quot;No doors field found&quot;) } Create and add new filter field // import &quot;github.com/neuronlabs/neuron/query/filters&quot; err = s.FilterField(filters.NewFilter(doorField, filters.OpGreaterEqual, 4)) if err != nil { // the error might occur if the field is not found within the model&#39;s // struct field panic(err) } Operators Neuron implements the following basic filter operators: ID Name Query String Value Variable Name Description 1 Equal $eq *filters.OpEqual Matches values that are equal to the specified value 2 In $in *filters.OpIn Matches any values that are in the specified range of values` 3 Not Equal $ne *filters.OpNotEqual Matches values that are not euqal to the specified value 4 Not In $nin *filters.OpNotIn Matches any values that are not in the specified range of values 5 Greater Than $gt *filters.OpGreaterThan Matches any value that is greater than the specified value 6 Greater Than Equal $ge *filters.OpGreaterEqual Matches any value that is greater than or equal to the specified value 7 Less Than $lt *filters.OpLessThan Matches any value that is smaller than the specified value 8 Less Than Equal $le *filters.OpLessEqual Matches any value that is smaller than or equal to the specified value 9 Contains $contains *filters.Contains The operator used for the string variables, matches any values that contains the specified string value 10 Starts With $startswith *filters.StartsWith Used for the string variables, matches any values that starts with the specified string value 11 Ends With $endsswith *filters.EndsWith Used for the string variables, matches any values that ends with the specified string value 12 Is Null $isnull *filters.IsNull Matches all objects for which given field value is null 13 Not Null $notnull *filters.NotNull Matches all objects for which given field value is not null It is also allowed to have the custom operator, which might be used within the hooks and changed into the basic filters, or used in pair with the required handler for the specific repository. Custom Operators Neuron allows to use the custom operators. In order to use it The operator should be registered in the github.com/neuronlabs/neuron/query/filters package as well as in the repository on which it would be used. The custom operator should be created in the following way: Create new *filters.Operator object: myOperator := &amp;filters.Operator{Name: &quot;MyOperator&quot;, Raw:&quot;$my&quot;} The operator should have unique Name nad Raw fields. The Raw field should start with the ‘$’ dollar sign. Then the operator should be registered in the query filters: if err = filters.RegisterOperator(myOperator); err != nil { panic(err) } If we want to use this operator in the specified repostiory we should register it there as well (if the implementation allows it) - probably with the handler Otherwise the operator might be used within hooks and then replaced into the basic operators",
    "url": "http://localhost:4000/neuron-core/query/filters.html",
    "relUrl": "/neuron-core/query/filters.html"
  },
  "8": {
    "id": "8",
    "title": "Get",
    "content": "Getting Single Data The neuron specifies separate function for getting just a single data instance from the repository. In order to get the single data we need to provide a model pointer to the new query scope methods: var u User // create new query for the s := norm.MustNew(&amp;u) // s.Collection() == &#39;users&#39; Filters In order to get a single data we should provide a filter. // add the filter to the scope for user with id=4 err = s.AddStringFilter(&quot;filter[users][id][$eq]&quot;, 4) Fieldset By providing the fieldset we can define what fields we would like to get from the repository. err = s.SetFieldset(&quot;id&quot;, &quot;name&quot;, &quot;age&quot;, &quot;pets&quot;) Pagination If provided filters doesn’t specify the primary field key, the scope may contain also a pagination offset: limit, offset := 1, 10 // set the limit and offset err = s.Limit(limit, offset) If the limit is greater than 1 the results would still contain a single instance in Get method. Methods When the query is prepared use the Get or GetContext methods for the query to get a single data instance from the repository. err = s.GetContext(ctx) if err != nil { // handle the error } Relations If the fieldset contains any relationship field, the query processor would take it’s primary field key and store in the relationship field’s primary. fmt.Println(u.Pets) // []*Pets{{ID: 5}, {ID: 10}}",
    "url": "http://localhost:4000/neuron-core/query/get.html",
    "relUrl": "/neuron-core/query/get.html"
  },
  "9": {
    "id": "9",
    "title": "Mongo Repository",
    "content": "Mongo Repository Work in progress. Neuron Mongo is the Neuron-Core MongoDB repository driver.",
    "url": "http://localhost:4000/neuron-mongo/",
    "relUrl": "/neuron-mongo/"
  },
  "10": {
    "id": "10",
    "title": "Query",
    "content": "Query Package: github.com/neuronlabs/neuron-core/query. Neuron-core’s architecture allows to query models with their relations located on separate databases, stores or services (Repositories). This requirement requires a lot of prices information about the given query. It’s structure is defined in the Scope which stores the parameters for each single query.",
    "url": "http://localhost:4000/neuron-core/query/",
    "relUrl": "/neuron-core/query/"
  },
  "11": {
    "id": "11",
    "title": "Models",
    "content": "Models Package: github.com/neuronlabs/neuron-core/mapping Neuron used struct types with specific fields as the models. The model structure were based on the JSON:API v1.0 specification. It’s design distinguished fields by their kinds. This feature made it easier to isolate the model’s by their own repositories. Neuron maps each model, analyze it’s fields with tags and creates *mapping.ModelStruct. These models are registered in the Controller.",
    "url": "http://localhost:4000/neuron-core/models",
    "relUrl": "/neuron-core/models"
  },
  "12": {
    "id": "12",
    "title": "Core ORM",
    "content": "Core ORM Neuron-core is the golang cloud-native, distributed ORM implementation. What is Neuron Core? Install Quickstart Packages Design What is Neuron Core? Neuron-core is a cloud-ready Golang ORM. It’s design allows to query multiple related models located on different datastores/repositories. Install go get -u github.com/neuronlabs/neuron-core Quick Start Define the models package models // User is the model that is stored on the &#39;main&#39; repository. // It is related to multiple &#39;Pet&#39; models. type User struct { ID int Name string Surname string Pets []*Pet `neuron:&quot;type=relation;foreign=OwnerID&quot;` } // Pet is the model related with the User. // It is stored in the &#39;secondary&#39; repository. type Pet struct { ID int Name string OwnerID int `neuron:&quot;type=foreign&quot;` } // RepositoryName implements RepositoryNamer interface. func (p *Pet) RepositoryName() string { return &quot;secondary&quot; } Import repositories and Create, Read or get Default *config.Controller package main import( // blank imported repository registers it&#39;s factory // and the driver. _ &quot;github.com/neuronlabs/neuron-pq&quot; ) import ( &quot;github.com/neuronlabs/neuron-core/config&quot; &quot;github.com/neuronlabs/neuron-core&quot; ) func main() { cfg := config.ReadDefaultConfig() // By setting the LogLevel the default logger would be used. cfg.LogLevel = &quot;debug&quot; ... Create the *controller.Controller and register repositories. // Provided create config &#39;cfg&#39; to the Controller method. c := ncore.Controller(cfg) // As the &#39;neuron-core&#39; allows to use multiple repository for the models // we can declare the DefaultRepository within the config. The first // registered repository would be set as the default as well. mainDB := &amp;config.Repository{ // Currently registered repository &#39;neuron-pq&#39; has it&#39;s driver name: &#39;pq&#39;. DriverName: &quot;pq&quot;, Host: &quot;localhost&quot;, Port: &quot;5432&quot;, Username: &quot;main_db_user&quot;, Password: &quot;main_db_password&quot;, DBName: &quot;main&quot;, } if err := c.RegisterRepository(&quot;main&quot;, mainDB); err != nil { panic(err) } // We can register and use different repository for other models. secondaryDB := &amp;config.Repository{ DriverName: &quot;pq&quot;, Host: &quot;172.16.1.10&quot;, Port: &quot;5432&quot;, Username: &quot;secondary_user&quot;, Password: &quot;secondary_password&quot;, DBName: &quot;secondary&quot;, } // Register secondary repository. if err := c.RegisterRepository(&quot;secondary&quot;, secondaryDB); err != nil { panic(err) } Register models if err := c.RegisterModels(models.User{}, models.Pet{}); err != nil { panic(err) } Query registered models users := []*User{} s := ncore.MustQueryC(c, &amp;users) // the query scope may be filtered s.AddStringFilter(&quot;filter[users][name][$in]&quot;,&quot;John&quot;, &quot;Sam&quot;) // it might also be sorted s.SortBy(&quot;-id&quot;) // list all the users with the name &#39;John&#39; or &#39;Sam&#39; with &#39;id&#39; ordered // descending. if err = s.List(); err != nil { panic(err) } Packages The neuron-core is composed of the following packages: query - used to query the model’s repositories. controller - is the neuron’s core, that registers and stores the models and contains configurations required by other packages. mapping - contains the information about the mapped models their fields and settings config - contains the configurations structures. encoding/jsonapi - allows to marshal and unmarshal the model’s, and queries by the https://jsonapi.org/ specification errors - used as a default error package for the neuron packages. errors/class - contains errors classification system for the neuron packages repository - is a package used to store, get and register the repositories nad their factories. log - is the logging interface for the neuron based applications. i18n - is the neuron based application supported internationalization common - common neuron variables, functions and definitions. Design The neuron-core is golang ORM implementation designed to process microservice repositories. This concept enhanced the requirements for the models mapping and query processor. The mapped models must have all the field’s with defined type. The initial model mapping was based on the JSONAPI v1.0 model definition. The distributed environment required each relationship to be specified of it’s kind and type, just as their foreign keys. The query processor needs to work as the orchestrator, choreographer. As each model’s repository might use different database, it needs to implement distributed transactions.",
    "url": "http://localhost:4000/neuron-core",
    "relUrl": "/neuron-core"
  },
  "13": {
    "id": "13",
    "title": "Gateway",
    "content": "Gateway Work in progress.",
    "url": "http://localhost:4000/neuron-gateway/",
    "relUrl": "/neuron-gateway/"
  },
  "14": {
    "id": "14",
    "title": "Postgres Repository",
    "content": "Postgres Repository Work in progress. Neuron PQ is the Neuron-Core Postgres repository driver.",
    "url": "http://localhost:4000/neuron-pq/",
    "relUrl": "/neuron-pq/"
  },
  "15": {
    "id": "15",
    "title": "Errors",
    "content": "Errors Standard golang errors are mostly compared by their messages. But what if we have multiple errors with the same logic meaning but different messages? This issue is solved by the Class abstraction. Package github.com/neuronlabs/errors provides simple golang error and classification primitives.",
    "url": "http://localhost:4000/errors",
    "relUrl": "/errors"
  },
  "16": {
    "id": "16",
    "title": "Neuron",
    "content": "Neuron Labs The Neuron is the Golang based project with a scope to deliver top quality, cloud-native, microservice ready framework for building and creating services. Table of Contents Core Errors Postgres Repository Mongo Repository Gateway",
    "url": "http://localhost:4000/",
    "relUrl": "/"
  },
  "17": {
    "id": "17",
    "title": "Insert",
    "content": "Insert data In order to insert the data create a new query with the provided value: user := &amp;User{Name: &quot;Jack&quot;} s, err := query.New(user) if err != nil { return err } Any create query may have specified it’s Selected Fields. The selected fields are the field’s which values would be inserted into repository. By default the query processor scans provided scope.Value for non-zero field values and uses them as the selected fields. By specifing selected fields the query might insert zero-valued fields. err = s.SelectFields(&quot;Name&quot;, &quot;Age&quot;) if err != nil { return err } When the create query preparation is finished then the Create method should be used on the query.Scope. err = s.Create() OR with respect to the provided context.Context: ctx, cancel := context.WithTimeout(context.Background, time.Second * 5) defer cancel() err = s.CreateContext(ctx) If the query.Scope doesn’t have primary field selected then the repository should create new model instance and set it’s ID value into model’s primary field value. id := user.ID // newly created model&#39;s ID Relations While inserting the model, neuron allows to set the relations for given model within a single query. If the relationship field primary field(s) is non-zero then after having the root model value created, the following relationship field would have it’s relationship model’s patched with the selected foreign keys. user := &amp;User{Name: &quot;Thomas&quot;, Pets: []*Pet{ID: 5}} s, err = query.New(user) if err != nil { return err } // the Create query would create new user with name Thomas // and patch pets model&#39;s with id: &#39;5&#39; so that it&#39;s foreign key is set // to newly created user&#39;s id. err = s.Create() if err != nil { return err } Errors While patching the related values an error might occur. If the query was within a single transaction, then // possible strategies: transaction: rollback all changes of the query non transactions: return error - this should be done within a transaction - any change might provide continue WithTimeout error",
    "url": "http://localhost:4000/neuron-core/query/insert.html",
    "relUrl": "/neuron-core/query/insert.html"
  },
  "18": {
    "id": "18",
    "title": "List",
    "content": "Listing data Listing the data is one of the most important ORM functions. Neuron allows to query along multiple repositories joining efficiently all the relations. By default while getting the relation data, neuron gets only relationship’s primary id’s. Prepare query scope Creating a List Query requires to provide an address of slice of models, to the query.New, query.NewC, query.MustNew, query.MustNewC functions: users := []*User{} s, err := query.New(&amp;users) Having prepared the query scope, we can specify what data we would like to obtain. // add the field filter if err = s.AddStringFilter(&quot;filter[users][id][$ne]&quot;, 51); err != nil { return err } limit := 5 offset := 12 // limit the values number at specific offset if err = s.Limit(limit, offset); err != nil { return err } // Set the return field set if err = s.SetFieldset(&quot;name&quot;, &quot;pets&quot;); err != nil { return err } // sort by the primary field in a decreasing order if err = s.SortBy(&quot;-id&quot;); err != nil { return err } Such prepared query Scope is ready for processing. The List or ListContext are the methods reponsible to list all the specified data instance from the repositories. // if we have a context we need to include into consider use ListContext method // otherwise choose List. if err = s.List(); err != nil { return err } // now the scope value - variable &#39;users&#39; should contain // the required values. As a result the arguments provided while creating the query scope would contain the data instances taken from repositories. If no data would be find for given query an error of class class.QueryValueNoResult would be returned. // use previously prepared query scope to list the data values err = s.List() if err != nil &amp;&amp; !errors.IsNoResult(err) { return err }",
    "url": "http://localhost:4000/neuron-core/query/list.html",
    "relUrl": "/neuron-core/query/list.html"
  },
  "19": {
    "id": "19",
    "title": "Pagination",
    "content": "Pagination The neuron allows to reduce the number of the given list results. It provides the pagination system, on the LimitOffset or Page base. Limit Offset The LimitOffset pagination type is well known from SQL. It limits the number of object with the Limit value and Offset says to skip as many objects from the current model’s results. // Let&#39;s limit the results up to lenght of 10 starting from the fifth + 1 limit, offset := 10, 5 err = scope.Limit(limit, offset) // an error might occur if the pagination is already set for the scope. Page Page based pagination uses PageSize and PageNumber variable to define the result. Each page should have results of size: PageSize, and have it’s PageNumber index. PageSize defines the number of objects to return. PageNumber is the index of current page. If each page contains: PageSize of objects, page number defines how many values should be skipped in the result. // Get results of page size &#39;20&#39; by skipping one page number (starting from // the &#39;2&#39; pageNumber. pageNumber, pageSize := 2, 20 // an error might occur if the pagination is already set on the query&#39;s scope. err = scope.Page(pageNumber, pageSize)",
    "url": "http://localhost:4000/neuron-core/query/pagination.html",
    "relUrl": "/neuron-core/query/pagination.html"
  },
  "20": {
    "id": "20",
    "title": "Patch",
    "content": "Patching single data The neuron allows to patch provided data instances in the repositories. It changes selected fields for the provided data model instance. Firstly the query scope needs to be created: // prepare the model data instance u := User{ // Primary key ID: 5, // Attribute Name: &quot;Anthony&quot;, // Relationship Pets: []*Pet{{ID: 5},{ID: 12}}, } // create new query scope for the &#39;u&#39; User. s := norm.MustNew(&amp;u) Fitler In order to patch, the query processor requires that the query scope must have any kind of filter. While providing the data with non zero primary key field, neuron processor would take it’s value and set as the primary key filter with $eq filter operator. Validation Each patching data might be validated before the operation starts. The validation is done by the gopkg.in/go-playground/validator.v9 validator. The default patch validator might be changed by setting controller’s PatchValidator. Selected Fields It is worth to emphasize that the Patch updates only the Selected fields. If no selected fields are provided for the query scope, the query processor would take all the non-zero values of the provided model. If we want to change the field’s value to it’s zero value i.e.: // Part is the example model containing zero-value attribute fields. type Part struct { ID int Price int Amount int } // set the model with it&#39;s primary key equal to &#39;1&#39; p := Part{ID: 1} // we want to patch the amount to &#39;0&#39; s := query.MustNew(&amp;p) // in order to use the &#39;Amount&#39; field it must be marked as selected. err = s.SelectField(&quot;Amount&quot;) if err != nil { // error might occur on misspeling the field name } Patching Methods When the query scope is ready for patching, use the query scope’s methods: Patch or PatchContext if the query should be based on the context.Context. err = s.Patch() if err != nil { // handle the patch error } Relations When the query scope has selected the relationship field the patch would change their values depending on the relationship type and field’s value. In future versions of the Core ORM each relationship would have it&#39;s change strategy. The strategy would differ the processes on data patching, depending on the user&#39;s choice. BelongsTo relationship In BelongsTo relationship the root model contains related foreign key for the relationship. If the selected relationship field would be a non nil, the processor copies it’s related primary field key into related foreign key. If it’s nil it would set it’s foreign key to zero value. HasOne relationship For models with selected HasOne relationship field, if it’s value is: non-zero model instance - then the processor would patch the related model’s foreign key. nil value - the processor clears the related model’s foreign key by setting it to zero-value. HasMany relationship For models with selected HasMany relationship field, if it’s value is: non-zero multi model instances - the processor clears old related models foreign keys and sets current related models foreign key field to the root model primary key field value. empty slice - the processor clears previous related model’s foreign keys that were equal to the root model’s primary key field value. ManyToMany relationship For models with selected Many2Many relationship field, if it’s value is: non-zero multi model instances - the processor clears old related models foreign keys in the join model and sets current related models foreign key field in the join model to the root model primary key field value. empty slice - the processor clears previous join model’s data instances where the foreign key is equal to the model’s primary key field value.",
    "url": "http://localhost:4000/neuron-core/query/patch.html",
    "relUrl": "/neuron-core/query/patch.html"
  },
  "21": {
    "id": "21",
    "title": "Processor",
    "content": "Query Processor Neuron core allows to specify the query processor processes. It implements both goroutine safe (default) and unsafe processors. The first one gets, patches, deletes the relationships one by one. The second does these processes concurently. The query processor might be set in the config.Controller. By default it uses thread safe processor (config.ThreadSafeProcessor). In order to change the processor to the concurent - use the config.ConcurrentProcessor configuration.",
    "url": "http://localhost:4000/neuron-core/processor.html",
    "relUrl": "/neuron-core/processor.html"
  },
  "22": {
    "id": "22",
    "title": "Relationships",
    "content": "Relationship Relationship is the structure that contains information about the relationship field for given model. It defines information such that: Kind - defines the relationship kind ForeignKey - is the struct field that defines relationship’s foreign key Join Model - (optional) used only for the ManyToMany models as the join model definition. ManyToManyForeignkey - (optional) is the foreign key used on the ManyToMany relationship that defines related model’s foreign key within the JoinModel Struct - defines the related model structure. Relationship kinds The relationship type might differ a lot in their structure and value number. Neuron specifies 4 main relationship kinds: Belongs to Has one Has many Many to many Belongs to The Belongs to relationship defines the single value relationship where it’s Foreign Key is stored within the root model. Example: Let’s define the root model with the belong’s to relationship: type User struct { ID int Name string FavoritePet *Pet PetID int } And the related model: type Pet struct { ID int Name string } The example User model contains BelongsTo relationship field with name FavoritePet and foreign key: PetID. Foreign key naming convention The default relationship foreign key naming conventions specify that the foreign key name should be: relationship’s struct field name + ID - example: FavoritePetID relationship’s struct name + ID - example: PetID If the other name is required for the model naming use the foreign tag with specified name on the relationship that uses this foreign key field. If the model or related model contains multiple fields with the matched foreig n key name the mapper prioritizes them as follows: Custom foreign key name (CustomForeignID) Relationships struct field name (FavoritePetID) Relationships struct name (PetID) Has one The HasOne relationship defines the single value relationship where the related model contains the Foreign Key. This relationship searches for the foreign key named from the model that contains relationship field instead of the foreign model (as in the BelongsTo relationship). Example: Define the model with HasOne relationship field: type Pet struct { ID int Name string Owner *User } Define the related model with the foreign key - this is the name of the related model with ID (as in the BelongsTo relationship) : type User struct { ID int Name string FavoritePet *Pet PetID int } The example Pet model contains the HasOne relationship field Owner which has it’s foreign key in the User model under the name PetID. Has Many The HasMany defines the many to one relationship between the models where the Foreign Keys are stored in the related models. This relationship searches for the foreign key named from the model that contains relationship field instead of the foreign model (as in the BelongsTo relationship). Example: Define the model with foreign key: type Human struct { ID int Name string Surname string // HouseID is the foreign key of the House.Owners has many relationship HouseID int } Define the model with the HasMany relationship field: type House struct { ID int Address string // Owners is the has many relationship field with the foreign key // stored in the Human model (HouseID) Owners []*Human } The example above defines two models: Human which contains ID, some attributes and a HouseID foreign key. House which contains ID, address attribute and the Owners HasMany relationship. The controller searches for the foreign key of names: OwnerID or HouseID. The second is found within the Human model. This relation can be paired with the opposite BelongsTo relationship, where the example House model has some BelongsTo relaitonship field to the House. Many to many The ManyToMany model is the most advance relationship type. It requires three models to involved: Model with relationship Related model Join model containing foreign keys By default the join model’s name should be a concantenation of the relationship models where the second is in plural form. In order to change it’s default name set the subtag with its name under the many2many tag. Example: Define model with relationship: type Class struct { ID int Title string Students []*Student `neuron:&quot;many2many&quot;` } The root model has the Students relationship field. It must be tagged with the many2many struct field tag. Define the related model: type Student struct { ID int Name string // Classes is the many2many relationship field // As the backreference field, it is not required to exists. Classes []*Class `neuron:&quot;many2many&quot;` } The backreference field in the related model is not required. If it exists it must be tagged with the many2many struct field tag. Define the join model: type ClassStudents struct { ID int StudentID int ClassID int } The join model may have attributes and other relationship fields (i.e.:BelongsTo relationships to the Class or Student) The above example shows how the three models could be defined for the ManyToMany relationship. The foreign struct field tag in the ManyToMany relationship may accept a subtag that defines custom join model name. In order to customize the foreign key names use foreign tag with two subtags as follows: The root model has the Students relationship field. It must be tagged with the foreign, and it’s custom foreign key name should be stored as the subtag. type Class struct { ID int Title string // Students many2many relationship field has both custom join model // and custom foreign key name. Students []*Student `neuron:&quot;many2many=CustomJoin;foreign=CustomClassID&quot;` } The backreference field in the related model is not required. If the related model’s foreign key have custom name it must be shown as the second subtag name in the foreign tag. If no custom foreign key name is used for this model but it is used for the related model use the _ subtag to separate the names. Define the related model: type Student struct { ID int Name string // Classes many2many relationship field has both custom join model and // custom related models foreign key name. Classes []*Class `neuron:&quot;many2many=CustomJoin;foreign=_,CustomClassID&quot;` } This join model has custom name different than default convention. It must be set in the many2many tag of the ManyToMany relationship fields. type CustomJoin struct { ID int // StudentID is the foreign key with default name. StudentID int // CustomClassID is the foreign key with custom - non default - name. CustomClassID int }",
    "url": "http://localhost:4000/neuron-core/models/relationship.html",
    "relUrl": "/neuron-core/models/relationship.html"
  },
  "23": {
    "id": "23",
    "title": "Repositories",
    "content": "Repositories Neuron-core use the repositories as the database/data store/service access. The main abstractions of the repositories are repository.Factory and a repository.Repository. Factory The Factory is the abstraction used to create new repository instances. It is also responsible for keeping the instances and closing them. Each factory have a unique driver name, which is used by the repositories configurations (*config.Repository) and by the *controller.Controller which is responsible to get the appropiate factory and create new repository instances for the models. The Factory should be registered within the neuron-core on package initialization. Custom factory skeleton may look like in the following example: package myfactory import ( &quot;context&quot; &quot;github.com/neuronlabs/neuron-core/mapping&quot; &quot;github.com/neuronlabs/neuron-core/repository&quot; ) // this factory should be registered on the blank import. func init(){ // this factory would be registered with the driver name // defined as in the factory &#39;DriverName&#39; method. if err := repository.RegisterFactory(&amp;Factory{}); err != nil { panic(err) } } // the Factory must implement repository.Factory interface. var _ repository.Factory = &amp;Factory{} // Factory is the neuron repository.Factory implementation // of the custom repository factory. // Implements repository.Factory. type Factory { instances []*Repository ... } // DriverName implements repository.Factory interface. func (f *Factory) DriverName() string { return &quot;myfactory&quot; } // New implements repository.Factory interface. func (f *Factory) New(c repository.Controller, model *mapping.ModelStruct) (repository.Repository, error) { // Do the logic and create (or use existing) repository instance. } // Close implements repository.Factory interface. func (f *Factory) Close(ctx context.Context, done chan&lt;-interface{}) { for _, instance := range f.instances { if err := instance.Close(ctx); err != nil { // handle the error } } // send the information that it finished the closing methods. done &lt;- struct{} } The repository.Factory is an interface used to create new instances of the repository.Repository. This interface requires to implement three methods: DriverName() - which gets the unique driver name for the given factory. New(c Controller,model *mapping.ModelStruct) (repository.Repository, error)- create new instance of the repository for given ‘model’. The Controller argument is an interface for the controllers that is used to get model structures. If the Repositories share similar connection configuration it may use the existing instance instead of creating new. The model specific repository configuration are obtainable by using model.Config().Repository Close(context.Context, done chan&lt;-interface{}) closes all the instances of the factory related repositories. Repository The Repository is the abstraction used to get the access to the data/service. It may be a used as the ORM access to the database, http.Client to some external service or just a custom accessability by using provided interfaces. The repository.Repository is the basic and required interface for the all the repository implementaions. The Repository instances should be created by it’s specific Factory. While registering the models, the controller stores the mapping between repositories and related models. All the Repository methods should not be used by the user directly. In order to access the data or service the Repository may implement specific interfaces defined in the query package like: Creator - creates and stores new instances of the model. Getter - gets a single instance of the specific model. Lister - lists multiple instances of the given model. Patcher - patches only selected model’s value. Deleter - deletes the model instances. Transactioner - allows to use the transactions. Creator func (r *Repository) (ctx context.Context, scope *query.Scope) error { // Do the create logic here return nil } The Create method of the Creator interface requires the Repository to create a specific model instance. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. Provided ‘scope’ structure contains multiple important information about given query like: scope.Value - scope.Value contains the model instance in a pointer to struct type. SelectedFields() - fields used in the current query.Scope. Only these fields should be stored by this query. It might be useful if a user would like to select and store the zero value fields. If the primary field is not selected, then the Repository should generate new primary field value and set it to the model’s scope.Value instance. Struct() - gets *mapping.ModelStruct for the specific query. The model structure has information about all it’s fields. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). Getter and Lister Getter func (r *Repository) Get(ctx context.Context, scope *query.Scope) error { // Do the get logic here return nil } Lister func (r *Repository) List(ctx context.Context, scope *query.Scope) error { // Do the logic here return nil } Both Get method from the Getter and List from the Lister interface should get a specific model instances for provided query ‘scope’. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. The get method must not return more than one value instance - (scope.Value is a pointer to the model struct). In order to narrow the scope of the query the *query.Scope contains multiple important information like: PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. Fieldset() - fieldset is a set of fields returned for each model for given query. Pagination() - a pagination paramters for given query. Get method must always return a single value, even if the pagination is limited to more than one result. scope.Value - the value where the results should be stored. It’s instance is already initialized and must not be overwritten. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If there no resultant value was found in related datastore/database then the repository should return an error with no result error classification. Patcher func (r *Repository) Patch(ctx context.Context, scope *query.Scope) error { // Do the patch logic here return nil } The Patch method from the Patcher interface should patch models with the values provided by the ‘scope’. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. Provided scope contains a single value instance with specific field values, with related filters used to narrow the query. The patch should update only the fields defined in the scope’s selected fields. Useful parameters stored in the scope: scope.Value - the value where the field’s values are stored. It’s instance is already initialized and must not replaced with new model’s instance. PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. SelectedFields() - fields used in the current query.Scope. Only these fields should be used by this query. It might be useful if a user would like to select and store the zero value fields. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If there no resultant value was found in related datastore/database then the repository should return an error with no result error classification. Deleter func (r *Repository) Delete(ctx context.Context, scope *query.Scope) error { // Do the delete logic. return nil } The Delete method from the Deleter interface should delete all the matching model instances defined by the given query scope. For any connection or other relatively long processes the function should check if the ‘ctx’ context is not Done yet. The scope should contain all the required filters: PrimaryFilters(), AttributeFilters(), ForeignKeyFilters(), FilterKeyFilters() - ‘scope’ methods used to get the specific field’s filters. The Repository should not use the RelationshipFilters() as the query processor converts them into other filters. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`). If no values were affected with given query then the repository should return an error with no result error classification. Transactioner The Transactioner interface requires the Repository to implement transactions for the specific queries. The transaction’s should be isolated for the specific Repository (the single repository might be used for multiple models with the same database). The scope has a Tx() method which returns the scope’s transaction structure. This structure contains the Transaction type and it’s unique ID - this value should be used to map the transaction instances. Begin func (r *Repository) Begin(ctx context.Context, scope *query.Scope) error { // Begin the transaction return nil } The Begin method should begin the repository specific transaction. In order to follow up the transactions the Repository on Begin should store related transactions ‘id’ with it’s specific structures - i.e. sql.Tx as well as Begin a transaction on it’s store/database. The transaction should be created with the specific ‘ctx’ context. Commit func (r *Repository) Commit(ctx context.Context, scope *query.Scope) error { // Commit the transaction changes return nil } If the query resulted with no error then the transaction should be commited. The Commit method allows to apply the transaction changes and remove the mapping transaction mapping. Rollback func (r *Repository) Rollback(ctx context.Context, scope *query.Scope) error { // Rollback any changes made by the transation. return nil } If the transaction were rolled back then the Rollback should undo the changes made within given transaction, and remove the transaction mapping. Any error returned by this method should be an instance of github.com/neuronlabs/neuron-core/errors Error or MultiError with defined error classification (``github.com/neuronlabs/neuron-core/errors/class`).",
    "url": "http://localhost:4000/neuron-core/repositories.html",
    "relUrl": "/neuron-core/repositories.html"
  },
  "24": {
    "id": "24",
    "title": "Scope",
    "content": "Scope Scope is the data structure that contains all the information about given query. It keeps the information about the filtering, sorting, pagination, fieldset, selected fields, value and many other meta data. Each of it is accessible from the *query.Scope instance as the methods or variables: ID - unique query id number (UUID) Value - Query’s value defines the values to be returned (GET and LIST), created (CREATE), changed (PATCH) or deleted (DELETE). Filters - query filters divided by the field types Primary Key filters Foreign Keys filters Attribute filters Relationship filters Filter Keys filters Fieldset - set of fields that must be returned with their values from the repository Selected Fields - set of fields selected to create/change any repository model Sorting Order - sorting order of the query Pagination - query paginations How to create a query Scope? A query scope can be created from the root github.com/neuronlabs/neuron-core or the github.com/neuronlabs/neuron-core/query package. In order to create a new Scope, it’s valid root model must be provided as well as the controller that keeps related models. Create with value A scope might be create with model value using ncore.Query, ncore.QueryC, ncore.MustQuery or ncore.MustQueryC. The functions with the ‘C’ ending requires the controller to be provided as the argument, whereas the other use default controller. Example Must: m := &amp;Model{ID: 3} // This function creates new scope with the default controller and // the model &#39;m&#39;. It panic on error. scope := ncore.MustQuery(m) Example QueryC: // supposed that we have already a controller &#39;c&#39; with registered &#39;Model&#39;. m := &amp;Model{ID: 2, Name: &quot;Anthony&quot;} // This takes the &#39;c&#39; controller and the model &#39;m&#39;. // Returns error if the model&#39;s value is not valid. scope, err := ncore.QueryC(c, m) These queries might be also created using direct access to the github.com/neuronlabs/neuron-core/query with methods such as: query.New, query.NewC, query.MustNew, query.MustNewC. The functions with ‘C’ endings requires the controller.Controller to be provided as argument, whereas the others would use the Default Controller. Scope allowed Values The scope keeps two types of values: single instance - it is a non-nil pointer to the value model. multiple instances - a non-nil pointer to the slice of pointers to models. Examples: single := Model{ID: 5} many := []*Model{{ID: 3}} // This would be correctly created scope - the value taken is an // address of model/slice instances. scope := query.MustNew(&amp;single) scope2 := query.MustNew(&amp;many) // This two would panic, the value taken are not pointers to the structures. scope = query.MustNew(single) scope = query.MustNew(many) Create scope with *ModelStruct The query might be also created using a *ModelStruct with the package github.com/neuronlabs/neuron-core/query. The method query.NewModelC is used to create scope with the ModelStructure. It requires controller to be provided as an argument, as well as information if the value of the query should be a slice or a single value instance isMany boolean. Created scope’s values would depend on the isMany flag, and their types would looks like: isMany - true - *[]*Type{} isMany - false - *Type{} Where the Type is the model registered in the controller. Example: // supposed that the controller &#39;c&#39; was previously // created with registered model &#39;Model&#39;. mStruct, _ := c.ModelStruct(Model{}) scope := query.NewModelC(c, mStruct, true) var many []*Model // scope&#39;s Value is a non-nil pointer of slice of pointer models temp := scope.Value.(*[]*Model) // dereference the pointer to get the slice of models. many = *temp",
    "url": "http://localhost:4000/neuron-core/query/scope.html",
    "relUrl": "/neuron-core/query/scope.html"
  },
  "25": {
    "id": "25",
    "title": "Selected Fields",
    "content": "Selected Fields For the queries where the provided input model would have usable values, the selected field defines are the fields that should be used by the processor. By default - (if no fields were selected for the query) all non-zero valued fields would be added to the query’s Selected Fields. If the zero-valued field should be used, it needs to be added to the query’s Selected Fields. JSONAPI It is also used by the encoding/jsonapi package. While unmarshaling the scope with specified values it selects only unmarshaled fields from the input data. Selected Fields methods The query allows to do multiple operations on the given scope. It allows to check what fields are selected, return all non selected fields, select single or multiple fields. Prepare the query scope: // User is the neuron model used for the purpose of this documentation. type User struct { ID int Name string `neuron:&quot;name=custom_name&quot;` Age int PhoneNumber string } // create model instance user := User{ID: 1, Name: &quot;Miguel&quot;, Age: 17} // scope := MustNew(&amp;user) IsSelected is selected checks if the provided argument ‘field’ is selected within the query’s scope. The field might be a string struct field Name, Neuron Name or a *mapping.StructField. // In order to check if the field is selected the function allows us to use multiple &#39;field&#39; types: // 1. StructField Name isNameSelected, err := scope.IsSelected(&quot;Name&quot;) // 2. Neuron Name isNameSelected, err = scope.IsSelected(&quot;custom_name&quot;) // 3. *mapping.StructField field, _ := s.Struct().FieldByName(&quot;Name&quot;) isNameSelected, err = scope.IsSelected(field) SelectField Selects the field in the scope’s query. The ‘field’ must be a string structfield’s Name or Neuron Name. // the err := scope.SelectField(&quot;Age&quot;) err = scope.SelectField(&quot;custom_names&quot;) SelectFields Clears the selected fields container for given query.Scope and adds argumented ‘fields’. Each field might be a string struct field Name, Neuron Name or a *mapping.StructField. // Each field may be of different type phoneNumber, _ := scope.Struct().FieldByName(&quot;PhoneNumber&quot;) err = scope.SelectFields(&quot;Age&quot;, &quot;custom_names&quot;, phoneNumber) AppendSelectedFields Appends provided fields to the selected fields container for given query.Scope. Each field might be a string struct field Name, Neuron Name or a *mapping.StructField. // Each field may be of different type phoneNumber, _ := scope.Struct().FieldByName(&quot;PhoneNumber&quot;) err = scope.AppendSelectedFields(&quot;Age&quot;, &quot;custom_names&quot;, phoneNumber) SelectedFields Lists all the selected fields in the query’s scope. Returns []*mapping.StructField. var selectedFields []*mapping.StructField selectedFields = scope.SelectedFields() NotSelectedFields Lists all the fields that were not selected in the query’s scope. Returns []*mapping.StructField. var notSelectedFields []*mapping.StructField notSelectedFields = scope.NotSelectedFields()",
    "url": "http://localhost:4000/neuron-core/query/selected_fields.html",
    "relUrl": "/neuron-core/query/selected_fields.html"
  },
  "26": {
    "id": "26",
    "title": "Sorts",
    "content": "Sorts Neuron allows to sort the List method results. The sorting is based on the provided field’s value. It allows both ascending and desceding ordering. NOTE: Current implementation allows sorting by the fields of the query scope&#39;s root model only. Scope Sorting By default scope sorts by the primary field values in ascending order. In order to sort the results by other fields, use the scope’s Sort method. The function takes multiple string ‘fields’ as an arguments. By default each sort field would be in ascending order. In order to change it into descending order the - sign should be used before given ‘field’. Example: // Sort the scope&#39;s result by the name, and if that matches sort by the age in // desceding order. err = scope.Sort(&quot;name&quot;, &quot;-age&quot;) This would result in sorting the results by the name. In case multiple fields would match, these would be sorted by the age in desceding order.",
    "url": "http://localhost:4000/neuron-core/query/sorts.html",
    "relUrl": "/neuron-core/query/sorts.html"
  },
  "27": {
    "id": "27",
    "title": "Structure",
    "content": "Model Structure The *ModelStruct is a data structure that stores all prepared information about the ‘model’. This document would base it’s examples on the provided models: // Bird is the neuron model used for the documentation. // It&#39;s fields have cardcoded neuron types. type Bird struct { ID int `neuron:&quot;type=primary&quot;` Name string `neuron:&quot;type=attr&quot;` Age int `neuron:&quot;type=attr&quot;` Specie *BirdSpecie `neuron:&quot;type=relation&quot;` BirdSpecieID int `neuron:&quot;type=foreign&quot;` } // BirdSpecie is the neuron model used for the documentation. // It defines the birds species. type BirdSpecie struct { ID int Name string } A model stores following variables: Type - specified reflect.Type that is dereferenced model type reflection. Collection - pluralized name converted using Controller&#39;s NamerFunc. Config - is the *config.Model matched for given model. Store - is the key:value storage for given model. Primary Key Field - is the *mapping.StructField of the model’s primary index field. Attribute Fields - (optional) model may contain multiple *mapping.StructField attributes. An attribute is the non related information about the model stored directly in the model’s repository. Relationship Fields - (optional) relationship fields represents references to the other models stored as struct fields. ForeignKey Fields - (optional) foreign keys are the fields directly connected with the relationship. It defines matched primary key of the related field’s model. Language Field - (optional) is a singleton (per model), optional field that defines lanaguage and i18n related values. Filter Key Fields - (optional) filter key fields are the fields which values are not stored within the model’s repository. Their value should be used to specify some state that might be usable in the Hooks. Registering Models Neuron requires to register the model before any operation starts. Registering model, stores it’s *mapping.ModelStruct in the Controller. A controller can have only a single model related to each reflect.Type and a single collection. Register the models with the RegisterModels Controller&#39;s method. It takes the model value instances as arguments. If a model have relationship fields, all the related models must be registered at once. The order of the provided models doesn’t matter. err := c.RegisterModels(Bird{}, BirdSpecie{}) if err != nil { // the model definition is invalid. return err } Getting Model Struct Having our models registered, we might want to use it’s mapping structure. This would be done by the Controller&#39;s ModelStruct method: modelStruct, err := c.ModelStruct(Bird{}) if err != nil { // the model is not found within given controller. return err }",
    "url": "http://localhost:4000/neuron-core/models/structure.html",
    "relUrl": "/neuron-core/models/structure.html"
  },
  "28": {
    "id": "28",
    "title": "Transactions",
    "content": "Transactions Neuron core is a cloud ready query processor. It’s design uses SAGA like transactions in the queries. This concept allows to safe queries along multiple repositories. Neuron query Scope implements a concept like scope chain. The chain is an array of queries (query.Scope) in an order at which it was executed. If the root scope uses a transaction, before processing a subscope creates a new transaction and adds itself to the root scope’s - scope chain. On success all scopes stored in the Scope chain sends Commit method, whereas on any failure a Rollback method would be called. The order of these calls is reverse to their position in the slice. Each repository keeps it’s own transaction abstraction. This concept allows to not use a Two-phase commit. Each repository focuses on its own local atomic transaction and other repositories are not blocked if a repository is running for a long time. Begin Commit Rollback Subscopes Begin Begin is the a method of the query.Transactioner interface that begins a transaction for given query. Commit Commit sends approvement of transaction changes to the repository. Implements query.Transactioner interface. Rollback Rollback rolls back the changes of the given transaction. It is used on transaction failures. Implements query.Transactioner interface. Subscopes In order to create a new subscope for given query.Scope use it’s New method. It creates a new scope for the provided model. The subscope is added to the root scope chain.",
    "url": "http://localhost:4000/neuron-core/query/transactions.html",
    "relUrl": "/neuron-core/query/transactions.html"
  }
  
}
